#+TITLE: Andrew's Tealeaf Lesson Two Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)


* "Object Oriented Programming with Ruby"

** Objected Oriented Programming

*** Why Objected Oriented Programming? 
*The Object Model*
Objected-Oriented Programming (OOP) is a paradigm that allows developers to manipulate parts of a program, without causing errors throughout the rest of the program. It simplifies the process of creating complicated programs, by breaking a large codebase into many smaller and more manageable parts.

*Encapsulation* allows programmers to protect data by hiding functionality from accidental manipulation. In Ruby, this accomplished by creating objects and methods that act upon these objects.

*Polymorphism* is term that describes the way that data can be represented in different forms. One example of polymorphism in Ruby is in inheritance, where smaller *subclasses* inherit the behaviors of larger *superclasses*.

Another example is in the use of *modules*. Modules, like classes, contain shared behavior. But you cannot create an obect with a module. Modules must be /mixed in/ with classes, using the reserved word *include*. This is called a *mixin*. Once a module has been mixed in, module functionality is available to the class and its objects.

** What are Objects?
Rubyists often declare, "In Ruby, everything is an object!" Objects are declared from classes. If classes were molds, objects would be the things produced from the molds. Objects contain different data, but they are instances of the same class.

For example:

#+BEGIN_SRC ruby
irb :001 > "hello".class
=> String
irb :002 > "world".class
=> String
#+END_SRC

Both "hello" and "world" are objects in the *String* class.

** Classes Define Objects
In Ruby, attributes and behaviors of objects are defined in *classes*. The syntax for defining a class is similar to a method, with a few differences:
- Instead of *def*, class definitions begin with *class*.
- Class names use CamelCase.
- Class definites finish with *end*.
- Ruby File names use snake_case, and reflect the class name.

*Instantiation* is the process of creating a new object or instance from a class, like this:

#+BEGIN_SRC ruby
# good_dog.rb

class GoodDog
end

sparky = GoodDog.new

#+END_SRC

Note that the class method *new* returns an object.

#+BEGIN_SRC ditaa :file good_dog_objects.jpg

                          +-------------------+
                          |                   |
                          |                   |
                          |   GoodDog Class   |
                          |                   |
                          |                   |
                          +--------+----------+
                                   |
                                   |
            +----------------------+----------------------+
            |                      |                      |
  +---------+---------+   +--------+---------+   +--------+---------+
  |  GoodDog Object   |   | GoodDog Object   |   | GoodDog Object   |
  |      sparky       |   |      fido        |   |      spot        |
  |                   |   |                  |   |                  |
  |  @name = "Sparky" |   | @name = "Fido"   |   | @name = "Spot"   |
  |  @age = 4         |   | @age = 6         |   | @age = 10        |
  +-------------------+   +------------------+   +------------------+

#+END_SRC

** Modules
"A module is a collection of behaviors that is useable in other classes via mixins. A module is "mixed in" to a class using the include reserved word" ([[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model][Source]]).

Modules allow us to share behaviors between classes. For example:

#+BEGIN_SRC ruby :tangle good_dog.rb
  # good_dog.rb

  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  sparky = GoodDog.new
  sparky.speak("Arf!")
  bob = HumanBeing.new
  bob.speak("Hello!")

#+END_SRC

In this example, both the *GoodDog* and *HumanBeing* classes can access the *speak* method, because the *Speak* module was mixed in both of them.

** Method Lookup
Ruby has a method lookup path (or chain) that it follows whenever a method is called. To find the method chain for any class, use the *ancestors* method:

#+BEGIN_SRC ruby
  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  puts "---GoodDog ancestors---"
  puts GoodDog.ancestors
  puts ' '
  puts "---HumanBeing ancestors---"
  puts HumanBeing.ancestors

#+END_SRC

Here is the output:

#+BEGIN_SRC ruby
---GoodDog ancestors---
GoodDog
Speak
Object
Kernel
BasicObject

---HumanBeing ancestors---
HumanBeing
Speak
Object
Kernel
BasicObject
#+END_SRC

As the [[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model#modules][authors explain]]:

#+BEGIN_SRC markdown

The Speak module is placed right in between our custom classes (i.e., GoodDog and HumanBeing) and the Object class that comes with Ruby. In Inheritance you'll see how the method lookup chain works when working with both mixins and class inheritance.

This means that since the speak method is not defined in the GoodDog class, the next place it looks is the Speak module. This continues in an ordered, linear fashion, until the method is either found, or there are no more places to look.

#+END_SRC

** Exercises

*** Problem 1
How do we create an object in Ruby? Give an example of the creation of an object.

*** Solution 1
We create an object through the process of *instantiation*:

#+BEGIN_SRC ruby
class HumanBeing
end

human_object = HumanBeing.new

#+END_SRC

*** Authors' solution:
We create an object by defining a class and instantiating it by using the .new method to create an instance, also known as an object.

#+BEGIN_SRC ruby
class MyClass
end

my_obj = MyClass.new
#+END_SRC

*** Problem 2
What is a module? What is its purpose? How do we use them with our classes? Create a module for the class you created in exercise 1 and include it properly.

*** Solution 2
Modules allow programmers to encapsulate behaviors and mix them into classes. Modules encourage *polymorphism*, by allowing the same data to be reused in different places, in different forms.

*** COMMENT Authors' solution:

A module allows us to group reusable code into one place. We use modules in our classes by using the *include* reserved word, followed by the module name. Modules are also used as a namespace.

#+BEGIN_SRC ruby
  module Study
  end

  class MyClass
    include Study
  end

  my_obj = MyClass.new
#+END_SRC

** Classes and Objects - Part 1

*** States and Behaviors
- We use classes to create objects.
- We usually focus on /states/ and /behaviors/.
- States track attributes for individual objects.
- Behaviors include anything that objects do.
- Instance variables store behaviors in classes, and states in objects.


Using the *GoodDog* class from before, we could create new *GoodDog* objects: "Fido" and "Sparky," each with different characteristics, like name, weight, age, or height. We can use *instance variables* to store these chracteristics.

*It's important to remember that instance variable are scoped at the object or instance level, and they are the mechanism for tracking object states.*

Because both "Fido" and "Sparky" are objects of the same *GoodDog* class, they share the same behaviors. For example, they can both run, bark, and fetch. These behaviors are stored as instance variable in the class, so they are available to all objects of that class (through inheritance).

*** Initializing a New Object
Using the same *GoodDog* class, we'll remove the old functionality and start over, by adding a new *initialize* method.

#+BEGIN_SRC ruby
  # good-dog.rb

  class GoodDog
    def initialize
      puts "This object was initilized!"
    end
  end

  sparky = GoodDog.new
#+END_SRC

The *initiliaze* method gets called every time we create a new object. As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]],
"In the above example, instantiating a new GoodDog object triggered the initialize method and resulted in the string being outputted. We refer to the initialize method as a constructor, because it gets triggered whenever we create a new object."

*** Instance Variables
The next example creates a new object and instantiates it with a new state (name).

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end
  end

#+END_SRC

The *@name* variable is an *instance variable*. Instance Varialbles:
- exists for as long as the object instance exists
- is a way to link data to objects
- does not "die" after the instance method is run
- *track information about the /state/ of an object*

In the example above, the initialize method takes a paramter, *name*. Using the *new* method to pass the argument *"Sparky"* through the initialize method, we can create a new object, using the *GoodDog* class we've just created:

#+BEGIN_SRC ruby
sparky = GoodDog.new("Sparky")
#+END_SRC

Within the constructor (i.e., the *initialize* method, the *@name* instance method is set to *name*, and the string "Sparky" is assigned to the *@name* instance variable.

In the example above, "Sparky" is the state of the @name instance variable. Another dog, like 'Fido' would indicate a different object state. Every object state is unique, and they are stored in instance variables.

*** Instance Methods
Let's give our *GoodDog* class more functionality:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak

#+END_SRC

We can also use string interpolation to change our *speak* method:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak
#+END_SRC

*** Accessor Methods

If we tried to print out only Sparky's name, we'd get a *NoMethodError: unefined method* error, which means that the method doesn't exist, or is not available to the object. 
