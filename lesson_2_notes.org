
+TITLE: Andrew's Tealeaf Lesson Two Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+OPTIONS: ^:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)


* "Object Oriented Programming with Ruby"

** Objected Oriented Programming

*** Why Objected Oriented Programming? 
*The Object Model*
Objected-Oriented Programming (OOP) is a paradigm that allows developers to manipulate parts of a program, without causing errors throughout the rest of the program. It simplifies the process of creating complicated programs, by breaking a large codebase into many smaller and more manageable parts.

*Encapsulation* allows programmers to protect data by hiding functionality from accidental manipulation. In Ruby, this accomplished by creating objects and methods that act upon these objects.

*Polymorphism* is term that describes the way that data can be represented in different forms. One example of polymorphism in Ruby is in inheritance, where smaller *subclasses* inherit the behaviors of larger *superclasses*.

Another example is in the use of *modules*. Modules, like classes, contain shared behavior. But you cannot create an obect with a module. Modules must be /mixed in/ with classes, using the reserved word *include*. This is called a *mixin*. Once a module has been mixed in, module functionality is available to the class and its objects.

** What are Objects?
Rubyists often declare, "In Ruby, everything is an object!" Objects are declared from classes. If classes were molds, objects would be the things produced from the molds. Objects contain different data, but they are instances of the same class.

For example:

#+BEGIN_SRC ruby
irb :001 > "hello".class
=> String
irb :002 > "world".class
=> String
#+END_SRC

Both "hello" and "world" are objects in the *String* class.

** Classes Define Objects
In Ruby, attributes and behaviors of objects are defined in *classes*. The syntax for defining a class is similar to a method, with a few differences:
- Instead of *def*, class definitions begin with *class*.
- Class names use CamelCase.
- Class definites finish with *end*.
- Ruby File names use snake_case, and reflect the class name.

*Instantiation* is the process of creating a new object or instance from a class, like this:

#+BEGIN_SRC ruby
# good_dog.rb

class GoodDog
end

sparky = GoodDog.new

#+END_SRC

Note that the class method *new* returns an object.

#+BEGIN_SRC ditaa :file good_dog_objects.jpg

                          +-------------------+
                          |                   |
                          |                   |
                          |   GoodDog Class   |
                          |                   |
                          |                   |
                          +--------+----------+
                                   |
                                   |
            +----------------------+----------------------+
            |                      |                      |
  +---------+---------+   +--------+---------+   +--------+---------+
  |  GoodDog Object   |   | GoodDog Object   |   | GoodDog Object   |
  |      sparky       |   |      fido        |   |      spot        |
  |                   |   |                  |   |                  |
  |  @name = "Sparky" |   | @name = "Fido"   |   | @name = "Spot"   |
  |  @age = 4         |   | @age = 6         |   | @age = 10        |
  +-------------------+   +------------------+   +------------------+

#+END_SRC

** Modules
"A module is a collection of behaviors that is useable in other classes via mixins. A module is "mixed in" to a class using the include reserved word" ([[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model][Source]]).

Modules allow us to share behaviors between classes. For example:

#+BEGIN_SRC ruby :tangle good_dog.rb
  # good_dog.rb

  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  sparky = GoodDog.new
  sparky.speak("Arf!")
  bob = HumanBeing.new
  bob.speak("Hello!")

#+END_SRC

In this example, both the *GoodDog* and *HumanBeing* classes can access the *speak* method, because the *Speak* module was mixed in both of them.

** Method Lookup
Ruby has a method lookup path (or chain) that it follows whenever a method is called. To find the method chain for any class, use the *ancestors* method:

#+BEGIN_SRC ruby
  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  puts "---GoodDog ancestors---"
  puts GoodDog.ancestors
  puts ' '
  puts "---HumanBeing ancestors---"
  puts HumanBeing.ancestors

#+END_SRC

Here is the output:

#+BEGIN_SRC ruby
---GoodDog ancestors---
GoodDog
Speak
Object
Kernel
BasicObject

---HumanBeing ancestors---
HumanBeing
Speak
Object
Kernel
BasicObject
#+END_SRC

As the [[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model#modules][authors explain]]:

#+BEGIN_SRC markdown

The Speak module is placed right in between our custom classes (i.e., GoodDog and HumanBeing) and the Object class that comes with Ruby. In Inheritance you'll see how the method lookup chain works when working with both mixins and class inheritance.

This means that since the speak method is not defined in the GoodDog class, the next place it looks is the Speak module. This continues in an ordered, linear fashion, until the method is either found, or there are no more places to look.

#+END_SRC

** Exercises

*** Problem 1
How do we create an object in Ruby? Give an example of the creation of an object.

*** Solution 1
We create an object through the process of *instantiation*:

*file:* [[object_model/exercise1.rb]]
#+BEGIN_SRC ruby :tangle object_model/exercise1.rb
# object_model/exercise1.rb

class HumanBeing
end

human_object = HumanBeing.new

#+END_SRC

*** Authors' solution:
We create an object by defining a class and instantiating it by using the .new method to create an instance, also known as an object.

#+BEGIN_SRC ruby
class MyClass
end

my_obj = MyClass.new
#+END_SRC

*** Problem 2
What is a module? What is its purpose? How do we use them with our classes? Create a module for the class you created in exercise 1 and include it properly.

*File:* [[object_model/exercise2.md]]
*** Solution 2
#+BEGIN_SRC markdown :tangle object_model/exercise2.md
Modules allow programmers to encapsulate behaviors and mix them into classes. Modules encourage *polymorphism*, by allowing the same data to be reused in different places, in different forms.
#+END_SRC


*File:* [[object_model/exercise2.rb]]
#+BEGIN_SRC ruby :tangle object_model/exercise2.rb
  # object_model/exercise2.rb
    module Study
    end

    class MyClass
      include Study
    end

    my_obj = MyClass.new
#+END_SRC

**** COMMENT Authors' solution:

A module allows us to group reusable code into one place. We use modules in our classes by using the *include* reserved word, followed by the module name. Modules are also used as a namespace.



** Classes and Objects - Part 1

*** States and Behaviors
- We use classes to create objects.
- We usually focus on /states/ and /behaviors/.
- States track attributes for individual objects.
- Behaviors include anything that objects do.
- Instance variables store behaviors in classes, and states in objects.


Using the *GoodDog* class from before, we could create new *GoodDog* objects: "Fido" and "Sparky," each with different characteristics, like name, weight, age, or height. We can use *instance variables* to store these chracteristics.

*It's important to remember that instance variable are scoped at the object or instance level, and they are the mechanism for tracking object states.*

Because both "Fido" and "Sparky" are objects of the same *GoodDog* class, they share the same behaviors. For example, they can both run, bark, and fetch. These behaviors are stored as instance variable in the class, so they are available to all objects of that class (through inheritance).

*** Initializing a New Object
Using the same *GoodDog* class, we'll remove the old functionality and start over, by adding a new *initialize* method.

#+BEGIN_SRC ruby
  # good-dog.rb

  class GoodDog
    def initialize
      puts "This object was initilized!"
    end
  end

  sparky = GoodDog.new
#+END_SRC

The *initiliaze* method gets called every time we create a new object. As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]],
"In the above example, instantiating a new GoodDog object triggered the initialize method and resulted in the string being outputted. We refer to the initialize method as a constructor, because it gets triggered whenever we create a new object."

*** Instance Variables
The next example creates a new object and instantiates it with a new state (name).

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end
  end

#+END_SRC

The *@name* variable is an *instance variable*. Instance Varialbles:
- exists for as long as the object instance exists
- is a way to link data to objects
- does not "die" after the instance method is run
- *track information about the /state/ of an object*

In the example above, the initialize method takes a paramter, *name*. Using the *new* method to pass the argument *"Sparky"* through the initialize method, we can create a new object, using the *GoodDog* class we've just created:

#+BEGIN_SRC ruby
sparky = GoodDog.new("Sparky")
#+END_SRC

Within the constructor (i.e., the *initialize* method, the *@name* instance method is set to *name*, and the string "Sparky" is assigned to the *@name* instance variable.

In the example above, "Sparky" is the state of the @name instance variable. Another dog, like 'Fido' would indicate a different object state. Every object state is unique, and they are stored in instance variables.

*** Instance Methods
Let's give our *GoodDog* class more functionality:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak

#+END_SRC

We can also use string interpolation to change our *speak* method:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak
#+END_SRC

*** Accessor Methods

If we tried to print out only Sparky's name, we'd get a *NoMethodError: unefined method* error, which means that the method doesn't exist, or is not available to the object. For example: 

#+BEGIN_SRC ruby
puts sparky.name
#+END_SRC

But because the *name* method is not available to the *sparky* object, we'd get an error similar to this:

#+BEGIN_SRC ruby
NoMethodError: undefined method `name' for #<GoodDog:0x007f91821239d0 @name="Sparky">
#+END_SRC

As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]], 

"If we want to access the object's name, which is stored in the @name instance variable, we have to create a method that will return the name. We can call it get_name, and its only job is to return the value in the @name instance variable."

#+BEGIN_SRC ruby
  #good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name

#+END_SRC

Now that we've added the *get_name* method, it should return the value of the *@name* instance variable.  

And here is the result:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
#+END_SRC

That worked, and we now have a /getter/ method. But what if, for example, we wanted to change *sparky*'s name? In that case, we'd need to use a /setter/ method:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def set_name=(name)
      @name = name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name
  sparky.set_name = "Spartacus"
  puts sparky.get_name

#+END_SRC

And the output would like like this:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
Spartacus
#+END_SRC

Ruby provides special syntatical sugar for the /setter/ method. Instead of the "normal" syntax we might expect, 

#+BEGIN_SRC ruby
sparky.set_name=("Spartacus")

#+END_SRC

We can simply type:

#+BEGIN_SRC ruby
sparky.set_name = "Spartacus"
#+END_SRC

Rubyists usually want to set the /getter/ and /setter/ names to match the instance variables they expose/set. We can refactor our code to reflect this convention:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def name   # This was renamed from "get_name"
      @ name
    end

    def name=(n)  # This was renamed from "set_name"
      @name = n
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.name = "Spartacus"
  puts sparky.net  # => "Spartacus"

#+END_SRC

The /getter/ and /setter/ methods above take up a lot of room. And if we had more states to define, it would take even more code. Fortunately, Ruby has a built-in way to automatically create these /getter/ and /setter/ methods for us, using the *attr_accessor* method!

Here is an example, refactoring the example above:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    attr_accessor :name

    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.net = "Spartacus"
  puts sparky.name  # => "Spartacus"

#+END_SRC

The output for this program is the same! The *attr_accessor* method takes a symbol as an argument, and uses that to create the method name for the *getter* and *seter* methods. 

To create only a *getter* method, without the *setter* method, use *attr_reader* instead.

To create on a *setter* method, without the *getter* method, use the *attr_writer* method.

You can add as many states as you want to any of the *attr_** methods, by simply adding more symbols. For example:

#+BEGIN_SRC ruby
attr_accessor :name, :height, :weight
#+END_SRC

The authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][warn]]:
/Side note: Don't confuse this with attr_accessible, which is a Rails concept. attr_accessor is part of Ruby and exposes getter and setter methods for objects. attr_accessible is a Rails 3 and earlier way of white-listing attributes for mass-assignment; it has since been replaced by strong_parameters in Rails 4./

*** Accessor Methods in Action
The *getter* and *setter* methods provide us with a way to expose and change the state of an object. We can also use these methods within the class as well. 

In the previous example, the *speak* method referenced the *@name* instance variable, like this:

#+BEGIN_SRC ruby
  def speak
    "#{@name} says arf!"
  end
#+END_SRC

Here, we're referencing the *@name* instance variable, but it's usually better to call the /getter/ method instead. Because we have created the *name* getter method along with the *attr_accessor*, we can reference *name* rather than the instance variable (@name):

#+BEGIN_SRC ruby
  def speak
    "#{name} says arf!"
  end
#+END_SRC

Referencing the *getter* method allows us to keep our code simpler. This can make it easier do things like make changes, refactor, or obfuscate data.

If we were to add two more states to the GoodDog class, "height" and "weight":

#+BEGIN_SRC ruby
attr_accessor :name, :height, :weight
#+END_SRC

That one line of code provides us with: 
- Six getter/setter methods,
  1. *name*
  2. *name=*
  3. *height*
  4. *height=*
  5. *weight*
  6. *weight=*
- Three instance varibles:
  1. *@name*
  2. *@height*
  3. *@weight*

What if we wanted to create a new method, called *change_info(n, h, w)*, which allowed us to change several states at once, and we used each of the three states as arguments? 

We could implement it this way:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    @name = n
    @height = h
    @weight = w
  end
#+END_SRC

Our *GoodDog* class now looks like this:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      @name = n
      @height = h
      @weight = w
    end

    def speak
      "#{name} says arf!"
    end
    
    def change_info(n, h, w)
      @name = n
      @height = h
      @weight = w
    end

    def info
      "#{name} weighs #{weight} and is #{height} tall."
    end
  end
#+END_SRC

And we can use the *change_info* method this way:

#+BEGIN_SRC ruby
  sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
  puts sparky.info      # => Sparky weighs 10 lbs and is 12 inches tall.

  sparky.change_info('Spartacus', '24 inches', '45 lbs')
  puts sparky.info      # => Spartabus weights 10 lbs and is 24 inches tall.
#+END_SRC
Just as we've used getter methods to avoid accessing instance variables directly, we can use setter methods to do the same. However, there is a small 'gotcha' to watch for with setter methods...For example, we can refactor the *change_info* method from above:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    name = n
    height= h
    weight = w
  end
#+END_SRC
But when we run it, nothing changes!

#+BEGIN_SRC ruby
  sparky.change_info('Spartacus', '24 inches', '45 lbs')
  puts sparky.info      # => Sparky weighs 10 lbs and is 12 inches tall.
#+END_SRC

*The reason nothing changed is that Ruby thought we were instantiating local variables!* In other words, instead of calling the *name=*, *height=*, and *weight=* setter methods, we created three new local variable: *name*, *height*, and *weight*.

To make it clear that we are not calling a local variable, we can use *self.name=* to show that we are calling a method. So we can now update our *change_info* code:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    self.name = n
    self.height = h
    self.weight = w
  end
#+END_SRC

This makes it clear that we are calling a setter method, and not creating a local variable. To be consistent, we could use the same syntax for the getter methods, but it is not necessary.

#+BEGIN_SRC ruby
  def info
    "#{self.name} weighs #{self.weight} and is #{self.height} tall."
  end
#+END_SRC

You can use the *self* prefix with any instance method; not just the accessor methods. For example, *info* is not a method included in *attr_accessor*, but we can call it with *self.info*:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    # ... preceding code ommited ...
    def some_method
      self.info
    end
  end
#+END_SRC

** Exercises

*** Exercise 1
Create a class called MyCar. When you initialize a new instance or object of the class, allow the user to define some instance variables that tell us the year, color, and model of the car. Create an instance variable that is set to 0 during instantiation of the object to track the current speed of the car as well. Create instance methods that allow the car to speed up, brake, and shut the car off.

*File:* [[classes_and_objects_1/exercise1.rb]]
*** Solution 1
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise1.rb
  # classes_and_objects_1/exercise1.rb

  class MyCar
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  civic = MyCar.new(2014, 'honda civic', 'brown')
  civic.speed_up(20)
  civic.current_speed
  civic.speed_up(20)
  civic.current_speed
  civic.brake(20)
  civic.current_speed
  civic.brake(20)
  civic.current_speed
  civic.shut_down
  civic.current_speed
#+END_SRC

*** Exercise 2
Add an accessor method to your MyCar class to change and view the color of your car. Then add an accessor method that allows you to view, but not modify, the year of your car.

*** Solution 2
*File:* classes_and_objects_1/exercise2.rb
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise2.rb

  class MyCar

    attr_accessor :color
    attr_reader :year

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  civic = MyCar.new(2014, 'honda civic', 'brown')
  puts civic.color
  civic.color = "blue"
  puts civic.color
  puts civic.year

#+END_SRC

*** Exercise 3
You want to create a nice interface that allows you to accurately describe the action you want your program to perform. Create a method called *spray_paint* that can be called on an object and will modify the color of the car.

*** Solution 3
*File:* classes_and_objects_1/exercise3.rb
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise3.rb
    class MyCar

      attr_accessor :color
      attr_reader :year

      def initialize(year, model, color)
        @year = year
        @model = model
        @color = color
        @current_speed = 0
      end

      def speed_up(number)
        @current_speed += number
        puts "You hit the gas and accelerate #{number} MPH."
      end

      def brake(number)
        @current_speed -= number
        puts "You hit the brakes and slow down #{number} MPH."
      end

      def current_speed
        puts "You're now going #{current_speed} MPH."
      end

      def shut_down
        @current_speed = 0
        puts "Let's park!"
      end

      def spray_paint(color)
        self.color = color
        puts "You painted your car #{color}? It looks like new!"
      end
    end

    civic = MyCar.new(2014, 'honda civic', 'brown')
    civic.spray_paint('blue')
#+END_SRC

And here's the result:
#+BEGIN_SRC sh
小A曰:ruby exercise3.rb
You painted your car blue? It looks like new!
#+END_SRC

** Classes and Objects II

*** Class Methods
Until now, all of the methods we've created have been instance methods. These methods relate to the instance or object of a class. *Class methods* can be called directly on the class itself, without needing to be instatiated first. 

When we define a class method, we prepend the method name with the reserved word *self*.

For example:

#+BEGIN_SRC ruby
  # good_dog.rb
  # ... the the rest of the code has been ommitted

  def  self.what_am_i    # Class method definition
    "I'm a GoodDog class!"
  end
#+END_SRC

To call a class method, we can prepend the name of the class to the method, without instantiating any objects, like this:

#+BEGIN_SRC ruby
GoodDog.what_am_i    # => I'm a GoodDog class!
#+END_SRC

Class methods are useful in situations where we want to add functonality that is not related to individual objects. Because objects have states, if we have a method that does not need to deal with states, we can simply use a class method. We'll see more practical examples in the next section.

*** Class Variables

In the same way that instance variables capture information and behaviors related to specific instances of classes (i.e., objects), *class variables* perform the same duties for entire classes.

To create a class variable, preceded the variable name with *@@*.

#+BEGIN_SRC ruby
  class GoodDog
    @@number_of_dogs = 0

    def initialize
      @@ number_of_dogs += 1
    end

    def self.total_number_of_dogs
      @@number_of_dogs
    end
  end

  puts GoodDog.total_number_of_dogs   # => 0

  dog1 = GoodDog.new
  dog2 = GoodDog.new

  puts GoodDog.total_number_of_dogs   # => 2
#+END_SRC

Here's a description of what's happening:
- *@@number_of_dogs* is a class variable, initialized to 0.
- *@@number_of_dogs* is incremented by 1 via the contructor (the *initialize* method).
- Every time we instantiate a new method (e.g., 'dog1 = GoodDog.new'), *initialize* is called. (Note that *initialize* is an instance method, and class methods can be called within instance methods).
- We return the value of the class variable in the class method *self.totla_number_of_dogs* (we use a class variable and a class method to track class-level details that pertain to class, and not to individual objects).

*** Constants
Predictably, class contants are variables that never change, and are defined with a capital letter at the beginning of the variable name. Rubyists usually capitalize the whole word, but only the first letter is mandatory.

#+BEGIN_SRC ruby
  class GoodDog
    DOG_YEARS = 7

    attr_accessor :name, :age

    def initialize(n, a)
      self.name = n
      self.age = a * DOG_YEARS
    end
  end

  sparky = GoodDog.new("Sparky", 4)
  puts sparky.age             # => 28
#+END_SRC

Here's what's happening:
1. The *DOG_YEARS* constant calculates the age of the object *sparky* in dog years.
2. The *attr_accessor* method provides the *@name* and *@age* instance methods, and provides corresponding /getter/ and /setter/ methods.
3. The *initialize* method's /setter/ method allows us to initialize the instance methods.
4. the *age* getter method allows us to retrive the objects's value.

*** The to_s Method

Using the built-in *to_s* method to inspect the *sparky* object that we've just created, we might get something like this:

#+BEGIN_SRC ruby
puts sparky      # => #<GoodDog:0x007fe542323320>
#+END_SRC

Because the *puts* method automatically calls *to_s* on its argument, the output here is the same as *puts sparky.to_s*.

We can test this by creating a custom *to_s* method on the *GoodDog* class to override the built-in method.

#+BEGIN_SRC ruby

  class GoodDog
    DOG_YEARS = 7

    attr_accessor :name, :age

    def initialize(n, a)
      self.name = n
      self.age = a * DOG_YEARS
    end

    def to_s
      "This dog's name is #{name} and it is #{age} in dog years."
    end
  end
#+END_SRC

The output has now changed:

#+BEGIN_SRC ruby
puts sparky      # => This dog's name is Sparky and is 28 in dog years.
#+END_SRC

The *to_s* method:
- is automatically called when using *puts*
- is automatically called in string interpolation

For example:

#+BEGIN_SRC sh
irb(main):001:0> array = [1, 2, 3]
array = [1, 2, 3]
=> [1, 2, 3]
irb(main):002:0> x = 5
x = 5
=> 5
irb(main):003:0> "The #{array} array doesn't include #{x}."
"The #{array} array doesn't include #{x}."
=> "The [1, 2, 3] array doesn't include 5."
#+END_SRC

What if we try to use string interpolation on the *sparky* object?

#+BEGIN_SRC sh
irb(main):004:0> "#{sparky}"
=> "This dog's name is Sparky and is 28 in dog years."
#+END_SRC

*Knowing that to_s is called when using puts or for string interpolation is very important for understanding and writing better OO code.*

*** More about self

*self* helps us designate a certain scope for our program. It can mean different things, in different contexts. According to the [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part2][authors]]:

For example, so far we've seen two clear use cases for self:

    Use *self* when calling setter methods from within the class. In our earlier example we showed that *self* was necessary in order for our *change_info* method to work properly. We had to use *self* to allow Ruby to disambiguate between initializing a local variable and calling a setter method. While not required, it's also a good idea to prepend *self* when calling all instance methods from within the class, not only for setter methods.

    Use *self* for class method definitions.

We can test this out:
#+BEGIN_SRC ruby
  class GoodDog
    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def change_info(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def info
      "#{self.name} weighs #{self.weight} and is #{self.height} tall."
    end
  end
#+END_SRC

We're using *self* whenever we call an instance method from within the class. But what exactly does *self* represent? To find out, we can add another instance method...

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog

    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def change_info(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def info
      "#{self.name} weighs #{self.weight} and is #{self.height} tall."
    end

    def what_is_self
      self
    end
  end
#+END_SRC

And if we instantiate a new *GoodDog* object and inspect it:

#+BEGIN_SRC ruby
irb(main):029:0> sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

irb(main):030:0> p sparky
p sparky
#<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

irb(main):031:0> puts sparky
puts sparky
#<GoodDog:0x007fdc73264448>
=> nil

irb(main):032:0> p sparky.what_is_self
p sparky.what_is_self
#<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

#+END_SRC

From within a class, when an instance method calls *self*, it returns the /calling method/, which in this case is the *sparky* object. From within the *change_info* method, calling *self.name=* is the same as calling *sparky.name=*. 

We also use the *self* method to define class methods:

#+BEGIN_SRC ruby
  class MyAwesomeClass
    def self.this_is_a_class_method
    end
  end
#+END_SRC

*self*, when inside a class but outside an instance method, actually refers to the class itself. So prefixing a method definition with *self* is the same as defining a method on the class. (i.e., *def self.a_method* == *def GoodDog.a_method*)

Within a class:

1. Inside instance methods, *self* references the calling object (the instance/object that called the method). *self.weight=* is equivalent to *sparky.weight=* in the example above.
2. Outside instance methods, *self* references the class, and can define class mehods. *def self.name=(n)* euivalent to *def GoodDog.name=(n)* in the example above.

Self allows us to explicitly reference things, as well as reveal the intended behavior. It's very important to pay attention to whether *self* is in an instance method or not, as it changes meaning, based on scope.

** Exercises

*** Exercise 1
Add a class method to your MyCar class that calculates the gas mileage of any car.

*** Solution 1
*File:* [[classes_and_objects_2/exercise1.rb]]
#+BEGIN_SRC ruby :tangle classes_and_objects_2/exercise1.rb
# classes_and_objects_2/exercise1.rb

  class MyCar

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  MyCar.gas_mileage(11, 389) # => "35 miles per gallon"
#+END_SRC

*** Exercise 2
Override the to_s method to create a user friendly print out of your object.

*** Solution 2
*File:* [[classes_and_objects_2/exercise2.rb]]
#+BEGIN_SRC ruby :tangle classes_and_objects_2/exercise2.rb
  # classes_and_objects_2/exercise2.rb

  class MyCar

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
    
    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  civic = MyCar.new("2014", "Honda Civic", "brown"}
  puts civic # => "My car is a brown, 2014, Honda Civic."
#+END_SRC

*** Exercise 3
When running the following code...

#+BEGIN_SRC ruby
  class Person
    attr_reader :name
    def initialize(name)
      @name = name
    end
  end

  bob = Person.new("Steve")
  bob.name = "Bob"
#+END_SRC

We get the following error...

#+BEGIN_SRC ruby
test.rb:9:in `<main>': undefined method `name=' for
  #<Person:0x007fef41838a28 @name="Steve"> (NoMethodError)
#+END_SRC

Why do we get this error and how to we fix it?

*** Solution 3
*File:* [[classes_and_objects_2/exercise3.md]]
#+BEGIN_SRC markdown :tangle classes_and_objects_2/exercise3.md
We get the error because the program use **attr_reader**, which creates a getter method, but not a setter method. But at the end, the program tries to set Bob's name.

To fix this, change **attr_reader** to **attr_writer** if you don't need the getter method, or set it to **attr_accessor** if you'd like to have both a getter and a setter method for the @name instance variable.
#+END_SRC

** Inheritance

Inheritance allows us to extract shared behavior from classes, and move it to a superclass. Inheritance allows us to keep our logic in one place, which makes our code better organized.

*** Class Inheritance
Extracting the *speak* method from the *GoodDog* class into a new *Animal* class allows us to make that behavior available to both the *GoodDog* and *Cat* classes.

#+BEGIN_SRC ruby
  # good_dog_class.rb

  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
  end

  class Cat < Animal
  end

  sparky = GoodDog.new
  paws = Cat.new
  puts spark.speak      # => Hello!
  puts paws.speak       # => Hello!

#+END_SRC

Both the *Cat* and *GoodDog* classes inherit the *speak* method. But we can override the speak method in subclasses. For example, we can add the original *speak* method back into *GoodDog*:

#+BEGIN_SRC ruby
  # good_dog_class.rb

  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
    attr_accessor :name

    def initialize(n)
      self.name = n
    end

    def speak
      "#{self.name} says arf!"
    end
  end

  class Cat < Animal
  end

  sparky = GoodDog.new("Sparky")
  paws = Cat.new

  puts sparky.speak       # => Sparky says arf!
  puts paws.speak         # => Hello!
#+END_SRC

*** super

*super* is a built-in function in ruby that allows us to call methods up the inheritance hierarchy. By calling *super* from inside a method, you instruct Ruby to search the inheritance hierarchy for a method of the same name. When it finds it, it invokes it. Here's an example:

#+BEGIN_SRC ruby
  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
    def speak
      super + " from GoodDog class"
    end
  end

  spearky = GoodDog.new
  sparky.speak           # => "Hello! from GoodDog class"
#+END_SRC


In this case, invoking *super* in the *GoodDog* class  allows us to call the *speak* class from the superclass (*Animal*), and then append a new string.

Another common way to use *super* is with *initialize*. For example:

#+BEGIN_SRC ruby
  class Animal
    attr_accessor :name

    def initialize(name)
      @name = name
    end
  end

  class GoodDog < Animal
    def initialize(color)
      super
      @color = color
    end
  end

  bruno = GoodDog.new("brown")       => #<GoodDog:0x007fb40b1e6718 @color="brown", @name="brown">
#+END_SRC
In this example, using *super* allows us to forward the arguments from the class where its called (the subclass) up to the superclass and invoke them.


When *super* is called with arguments, the arguments are passed up the method lookup chain:

#+BEGIN_SRC ruby
  class BadDog < Animal
    def initialize(age, name)
      super(name)
      @age = age
    end
  end

  BadDog.new(2, "bear")   => #<BadDog:0x007fb40b2beb68 @age=2, @name="bear">
#+END_SRC

In this example, argument *name* is passed by up to the superclass and set to the *@name* instance variable.

*** Mixing in Modules
Modules offer another way to follow the DRY principle in Ruby.

By extracting common methods to a superclass, we can simplify our code and model concepts that follow a natural hierarchy. For example, we can extract the shared, common behavior of the *Cat* and *Dog* classes we've made into a new *Mammal* class, and add a *Fish* class outside the mammal class:

#+BEGIN_SRC ditaa :file inheritance/animal_classes.png :cmdline -r
            +----------+
            |  Animal  |
            +----++----+
                 ||             
       +---------/\-----------+     
       |                      |     
  +----+----+            +----+---+ 
  |  Fish   |            | Mammal |     
  +---------+            +---+-+--+ 
                             | |    
                             | |    
                             | |    
                 +-------+   | |   +-------+
                 |  Cat  +---/ \---+  Dog  |
                 +-------+         +-------+

#+END_SRC

However, as our programs grow in complexity, we face a new problem. We don't want to repeat our code in different classes, but when some subclasses do not share the same behavior, we cannot add it to the superclass.

Modules provide a way to abstract behavior, which can then be mixed in to the appropriate classes. Taking the example above, if we wanted to add in a *swim* method to the *Fish* and *Dog* classes only, we could create a module, and add them to those classes, like this:

#+BEGIN_SRC ruby
  module Swimmable
    def swim
      "I'm swimming!"
    end
  end

  class Animal; end

  class Fish < Animal
    include Swimmable          # mixing in the Swimmable module
  end

  class Mammal < Animal
  end

  class Cat < Mammal
  end

  class Dog < Mammal
    include Swimmable          # mixing in the Swimmable module
  end
#+END_SRC

Result:
#+BEGIN_SRC ruby
sparky = Dog.new
neemo  = Fish.new
paws   = Cat.new

sparky.swim                 # => I'm swimming!
neemo.swim                  # => I'm swimming!
paws.swim                   # => NoMethodError: undefined method `swim' for 

#<Cat:0x007fc453152308>
#+END_SRC


/Note: using the prefix '~able' to describe actions, as in the 'Swimmable' example above, is a common Ruby convention./

*** Inheritance vs. Modules

Here are some guidelines for choosing between inheritance and modules:

- Classes can only be the subclass of one superclass. But you can mix in as many modules as you want.
- For 'is-a' relationshiops: choose class inheritance. For 'has-a' relationship, modules are the better choice. For example: a dog 'is an' animal (class inheritance; Dog < Animal), and a dog "has an" ability to swim (Swimmable module).
- Modules can't be instantiated, so they cannot be used to create objects. Modules are only used for namespacing and grouping common methods together.

*** Method Lookup Path
We can use inheritance and mixins to view the hierarchy of classes are looked up when a method is called:

#+BEGIN_SRC ruby
  module Walkable
    def walk
      "I'm walking."
    end
  end

  module Swimmable
    def swim
      "I'm swimming."
    end
  end

  module Climbable
    def climb
      "I'm climbing."
    end
  end

  class Animal
    include Walkable

    def speak
      "I'm an animal, and I speak!"
    end
  end
#+END_SRC

There are three modules and one class here. One of the modules (*Walkable*) has been mixed into the *Animal* class. We can use the *ancestors* class method to trace the method lookup path:

#+BEGIN_SRC ruby
puts "---Animal method lookup---"
puts Animal.ancestors
#+END_SRC

Here's the output:

#+BEGIN_SRC sh
---Animal method lookup---
Animal
Walkable
Object
Kernel
BasicObject
#+END_SRC

When Ruby finds the appropriate method in the current class, it looks no futher:

#+BEGIN_SRC ruby
fido = Animal.new
fido.speak                  # => I'm an animal, and I speak!
#+END_SRC

If the method is not found in the current class, it will go up the chain, until it finds the method, and execute it.

#+BEGIN_SRC ruby
fido.walk                   # => I'm walking.
#+END_SRC

If Ruby traverses all the classes and modules in the method lookup list, and doesn't find it, it throws an error:

#+BEGIN_SRC ruby
fido.swim
  # => NoMethodError: undefined method `swim' for #<Animal:0x007f92832625b0>
#+END_SRC

What if we add another class, that inherits from the *Animal* class, and mixes in the *Swimmable* and *Climbable* modules?

#+BEGIN_SRC ruby
  class GoodDog < Animal
    include Swimmable
    include Climbable
  end

puts "---GoodDog method lookup---"
puts GoodDog.ancestors
#+END_SRC

Here's the output:

#+BEGIN_SRC sh
---GoodDog method lookup---
GoodDog
Climbable
Swimmable
Animal
Walkable
Object
Kernel
BasicObject
#+END_SRC

A few things to note about the output:
- The order in which we include modules is important. Ruby looks at the last module included /first/. (If we included two or more modules with methods that had the same name, the last module included would be referenced first.)
- The moduled included in the superclass made it into the method lookup path. (Thus, all *GoodDog* objects will have access to *Walkable* and any other modules mixed in to its superclasses, in addition the *Animal* superclass.)
- Understanding the method lookup list is essential for large, complicated projects.

*** More Modules
