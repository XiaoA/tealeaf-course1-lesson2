#+TITLE: Andrew's Tealeaf Lesson Two Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)


* "Object Oriented Programming with Ruby"

** Objected Oriented Programming

*** Why Objected Oriented Programming? 
*The Object Model*
Objected-Oriented Programming (OOP) is a paradigm that allows developers to manipulate parts of a program, without causing errors throughout the rest of the program. It simplifies the process of creating complicated programs, by breaking a large codebase into many smaller and more manageable parts.

*Encapsulation* allows programmers to protect data by hiding functionality from accidental manipulation. In Ruby, this accomplished by creating objects and methods that act upon these objects.

*Polymorphism* is term that describes the way that data can be represented in different forms. One example of polymorphism in Ruby is in inheritance, where smaller *subclasses* inherit the behaviors of larger *superclasses*.

Another example is in the use of *modules*. Modules, like classes, contain shared behavior. But you cannot create an obect with a module. Modules must be /mixed in/ with classes, using the reserved word *include*. This is called a *mixin*. Once a module has been mixed in, module functionality is available to the class and its objects.

** What are Objects?
Rubyists often declare, "In Ruby, everything is an object!" Objects are declared from classes. If classes were molds, objects would be the things produced from the molds. Objects contain different data, but they are instances of the same class.

For example:

#+BEGIN_SRC ruby

#+END_SRC

Both "hello" and "world" are objects in the *String* class.

** Classes Define Objects
In Ruby, attributes and behaviors of objects are defined in *classes*. The syntax for defining a class is similar to a method, with a few differences:
- Instead of *def*, class definitions begin with *class*.
- Class names use CamelCase.
- Class definites finish with *end*.
- Ruby File names use snake_case, and reflect the class name.

*Instantiation* is the process of creating a new object or instance from a class, like this:

#+BEGIN_SRC ruby
# good_dog.rb

class GoodDog
end

sparky = GoodDog.new

#+END_SRC

Note that the class method *new* returns an object.

** COMMENT Modules
"A module is a collection of behaviors that is useable in other classes via mixins. A module is "mixed in" to a class using the include reserved word" ([[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model][Source]]).

Modules allow us to share behaviors between classes. For example:

#+BEGIN_SRC ruby :tangle good_dog.rb
  # good_dog.rb

  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  sparky = GoodDog.new
  sparky.speak("Arf!")
  bob = HumanBeing.new
  bob.speak("Hello!")

#+END_SRC

In this example, both the *GoodDog* and *HumanBeing* classes can access the *speak* method, because the *Speak* module was mixed in both of them.

** Method Lookup
Ruby has a method lookup path (or chain) that it follows whenever a method is called. To find the method chain for any class, use the *ancestors* method:

#+BEGIN_SRC ruby
  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  puts "---GoodDog ancestors---"
  puts GoodDog.ancestors
  puts ' '
  puts "---HumanBeing ancestors---"
  puts HumanBeing.ancestors

#+END_SRC

Here is the output:

#+BEGIN_SRC ruby
---GoodDog ancestors---
GoodDog
Speak
Object
Kernel
BasicObject

---HumanBeing ancestors---
HumanBeing
Speak
Object
Kernel
BasicObject
#+END_SRC

As the [[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model#modules][authors explain]]:

#+BEGIN_SRC markdown

The Speak module is placed right in between our custom classes (i.e., GoodDog and HumanBeing) and the Object class that comes with Ruby. In Inheritance you'll see how the method lookup chain works when working with both mixins and class inheritance.

This means that since the speak method is not defined in the GoodDog class, the next place it looks is the Speak module. This continues in an ordered, linear fashion, until the method is either found, or there are no more places to look.

#+END_SRC

** Exercises

*** Problem 1
How do we create an object in Ruby? Give an example of the creation of an object.

*** Solution 1
We create an object through the process of *instantiation*:

#+BEGIN_SRC ruby
class HumanBeing
end

human_object = HumanBeing.new

#+END_SRC

*** Author's solution:
We create an object by defining a class and instantiating it by using the .new method to create an instance, also known as an object.

#+BEGIN_EXAMPLE ruby
class MyClass
end

my_obj = MyClass.new
#+END_EXAMPLE



