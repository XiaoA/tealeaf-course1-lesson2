+TITLE: Andrew's Tealeaf Lesson Two Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+OPTIONS: ^:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)


* "Object Oriented Programming with Ruby"

** Objected Oriented Programming

*** Why Objected Oriented Programming? 
*The Object Model*
Objected-Oriented Programming (OOP) is a paradigm that allows developers to manipulate parts of a program, without causing errors throughout the rest of the program. It simplifies the process of creating complicated programs, by breaking a large codebase into many smaller and more manageable parts.

*Encapsulation* allows programmers to protect data by hiding functionality from accidental manipulation. In Ruby, this accomplished by creating objects and methods that act upon these objects.

*Polymorphism* is term that describes the way that data can be represented in different forms. One example of polymorphism in Ruby is in inheritance, where smaller *subclasses* inherit the behaviors of larger *superclasses*.

Another example is in the use of *modules*. Modules, like classes, contain shared behavior. But you cannot create an obect with a module. Modules must be /mixed in/ with classes, using the reserved word *include*. This is called a *mixin*. Once a module has been mixed in, module functionality is available to the class and its objects.

** What are Objects?
Rubyists often declare, "In Ruby, everything is an object!" Objects are declared from classes. If classes were molds, objects would be the things produced from the molds. Objects contain different data, but they are instances of the same class.

For example:

#+BEGIN_SRC ruby
irb :001 > "hello".class
=> String
irb :002 > "world".class
=> String
#+END_SRC

Both "hello" and "world" are objects in the *String* class.

** Classes Define Objects
In Ruby, attributes and behaviors of objects are defined in *classes*. The syntax for defining a class is similar to a method, with a few differences:
- Instead of *def*, class definitions begin with *class*.
- Class names use CamelCase.
- Class definites finish with *end*.
- Ruby File names use snake_case, and reflect the class name.

*Instantiation* is the process of creating a new object or instance from a class, like this:

#+BEGIN_SRC ruby
# good_dog.rb

class GoodDog
end

sparky = GoodDog.new

#+END_SRC

Note that the class method *new* returns an object.

#+BEGIN_SRC ditaa :file good_dog_objects.jpg

                          +-------------------+
                          |                   |
                          |                   |
                          |   GoodDog Class   |
                          |                   |
                          |                   |
                          +--------+----------+
                                   |
                                   |
            +----------------------+----------------------+
            |                      |                      |
  +---------+---------+   +--------+---------+   +--------+---------+
  |  GoodDog Object   |   | GoodDog Object   |   | GoodDog Object   |
  |      sparky       |   |      fido        |   |      spot        |
  |                   |   |                  |   |                  |
  |  @name = "Sparky" |   | @name = "Fido"   |   | @name = "Spot"   |
  |  @age = 4         |   | @age = 6         |   | @age = 10        |
  +-------------------+   +------------------+   +------------------+

#+END_SRC

** Modules
"A module is a collection of behaviors that is useable in other classes via mixins. A module is "mixed in" to a class using the include reserved word" ([[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model][Source]]).

Modules allow us to share behaviors between classes. For example:

#+BEGIN_SRC ruby :tangle good_dog.rb
  # good_dog.rb

  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  sparky = GoodDog.new
  sparky.speak("Arf!")
  bob = HumanBeing.new
  bob.speak("Hello!")

#+END_SRC

In this example, both the *GoodDog* and *HumanBeing* classes can access the *speak* method, because the *Speak* module was mixed in both of them.

** Method Lookup
Ruby has a method lookup path (or chain) that it follows whenever a method is called. To find the method chain for any class, use the *ancestors* method:

#+BEGIN_SRC ruby
  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  puts "---GoodDog ancestors---"
  puts GoodDog.ancestors
  puts ' '
  puts "---HumanBeing ancestors---"
  puts HumanBeing.ancestors

#+END_SRC

Here is the output:

#+BEGIN_SRC ruby
---GoodDog ancestors---
GoodDog
Speak
Object
Kernel
BasicObject

---HumanBeing ancestors---
HumanBeing
Speak
Object
Kernel
BasicObject
#+END_SRC

As the [[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model#modules][authors explain]]:

#+BEGIN_SRC markdown

The Speak module is placed right in between our custom classes (i.e., GoodDog and HumanBeing) and the Object class that comes with Ruby. In Inheritance you'll see how the method lookup chain works when working with both mixins and class inheritance.

This means that since the speak method is not defined in the GoodDog class, the next place it looks is the Speak module. This continues in an ordered, linear fashion, until the method is either found, or there are no more places to look.

#+END_SRC

** Exercises

*** Problem 1
How do we create an object in Ruby? Give an example of the creation of an object.

*** Solution 1
We create an object through the process of *instantiation*:

#+BEGIN_SRC ruby
class HumanBeing
end

human_object = HumanBeing.new

#+END_SRC

*** Authors' solution:
We create an object by defining a class and instantiating it by using the .new method to create an instance, also known as an object.

#+BEGIN_SRC ruby
class MyClass
end

my_obj = MyClass.new
#+END_SRC

*** Problem 2
What is a module? What is its purpose? How do we use them with our classes? Create a module for the class you created in exercise 1 and include it properly.

*** Solution 2
Modules allow programmers to encapsulate behaviors and mix them into classes. Modules encourage *polymorphism*, by allowing the same data to be reused in different places, in different forms.

*** COMMENT Authors' solution:

A module allows us to group reusable code into one place. We use modules in our classes by using the *include* reserved word, followed by the module name. Modules are also used as a namespace.

#+BEGIN_SRC ruby
  module Study
  end

  class MyClass
    include Study
  end

  my_obj = MyClass.new
#+END_SRC

** Classes and Objects - Part 1

*** States and Behaviors
- We use classes to create objects.
- We usually focus on /states/ and /behaviors/.
- States track attributes for individual objects.
- Behaviors include anything that objects do.
- Instance variables store behaviors in classes, and states in objects.


Using the *GoodDog* class from before, we could create new *GoodDog* objects: "Fido" and "Sparky," each with different characteristics, like name, weight, age, or height. We can use *instance variables* to store these chracteristics.

*It's important to remember that instance variable are scoped at the object or instance level, and they are the mechanism for tracking object states.*

Because both "Fido" and "Sparky" are objects of the same *GoodDog* class, they share the same behaviors. For example, they can both run, bark, and fetch. These behaviors are stored as instance variable in the class, so they are available to all objects of that class (through inheritance).

*** Initializing a New Object
Using the same *GoodDog* class, we'll remove the old functionality and start over, by adding a new *initialize* method.

#+BEGIN_SRC ruby
  # good-dog.rb

  class GoodDog
    def initialize
      puts "This object was initilized!"
    end
  end

  sparky = GoodDog.new
#+END_SRC

The *initiliaze* method gets called every time we create a new object. As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]],
"In the above example, instantiating a new GoodDog object triggered the initialize method and resulted in the string being outputted. We refer to the initialize method as a constructor, because it gets triggered whenever we create a new object."

*** Instance Variables
The next example creates a new object and instantiates it with a new state (name).

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end
  end

#+END_SRC

The *@name* variable is an *instance variable*. Instance Varialbles:
- exists for as long as the object instance exists
- is a way to link data to objects
- does not "die" after the instance method is run
- *track information about the /state/ of an object*

In the example above, the initialize method takes a paramter, *name*. Using the *new* method to pass the argument *"Sparky"* through the initialize method, we can create a new object, using the *GoodDog* class we've just created:

#+BEGIN_SRC ruby
sparky = GoodDog.new("Sparky")
#+END_SRC

Within the constructor (i.e., the *initialize* method, the *@name* instance method is set to *name*, and the string "Sparky" is assigned to the *@name* instance variable.

In the example above, "Sparky" is the state of the @name instance variable. Another dog, like 'Fido' would indicate a different object state. Every object state is unique, and they are stored in instance variables.

*** Instance Methods
Let's give our *GoodDog* class more functionality:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak

#+END_SRC

We can also use string interpolation to change our *speak* method:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak
#+END_SRC

*** Accessor Methods

If we tried to print out only Sparky's name, we'd get a *NoMethodError: unefined method* error, which means that the method doesn't exist, or is not available to the object. For example: 

#+BEGIN_SRC ruby
puts sparky.name
#+END_SRC

But because the *name* method is not available to the *sparky* object, we'd get an error similar to this:

#+BEGIN_SRC ruby
NoMethodError: undefined method `name' for #<GoodDog:0x007f91821239d0 @name="Sparky">
#+END_SRC

As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]], 

"If we want to access the object's name, which is stored in the @name instance variable, we have to create a method that will return the name. We can call it get_name, and its only job is to return the value in the @name instance variable."

#+BEGIN_SRC ruby
  #good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name

#+END_SRC

Now that we've added the *get_name* method, it should return the value of the *@name* instance variable.  

And here is the result:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
#+END_SRC

That worked, and we now have a /getter/ method. But what if, for example, we wanted to change *sparky*'s name? In that case, we'd need to use a /setter/ method:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def set_name=(name)
      @name = name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name
  sparky.set_name = "Spartacus"
  puts sparky.get_name

#+END_SRC

And the output would like like this:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
Spartacus
#+END_SRC

Ruby provides special syntatical sugar for the /setter/ method. Instead of the "normal" syntax we might expect, 

#+BEGIN_SRC ruby
sparky.set_name=("Spartacus")

#+END_SRC

We can simply type:

#+BEGIN_SRC ruby
sparky.set_name = "Spartacus"
#+END_SRC

Rubyists usually want to set the /getter/ and /setter/ names to match the instance variables they expose/set. We can refactor our code to reflect this convention:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def name   # This was renamed from "get_name"
      @ name
    end

    def name=(n)  # This was renamed from "set_name"
      @name = n
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.name = "Spartacus"
  puts sparky.net  # => "Spartacus"

#+END_SRC

The /getter/ and /setter/ methods above take up a lot of room. And if we had more states to define, it would take even more code. Fortunately, Ruby has a built-in way to automatically create these /getter/ and /setter/ methods for us, using the *attr_accessor* method!

Here is an example, refactoring the example above:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    attr_accessor :name

    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.net = "Spartacus"
  puts sparky.name  # => "Spartacus"

#+END_SRC

The output for this program is the same! The *attr_accessor* method takes a symbol as an argument, and uses that to create the method name for the *getter* and *seter* methods. 

To create only a *getter* method, without the *setter* method, use *attr_reader* instead.

To create on a *setter* method, without the *getter* method, use the *attr_writer* method.

You can add as many states as you want to any of the *attr_** methods, by simply adding more symbols. For example:

#+BEGIN_SRC ruby
attr_accessor :name, :height, :weight
#+END_SRC

The authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][warn]]:
/Side note: Don't confuse this with attr_accessible, which is a Rails concept. attr_accessor is part of Ruby and exposes getter and setter methods for objects. attr_accessible is a Rails 3 and earlier way of white-listing attributes for mass-assignment; it has since been replaced by strong_parameters in Rails 4./

** Accessor Methods in Action
The *getter* and *setter* methods provide us with a way to expose and change the state of an object. We can also use these methods within the class as well. 

In the previous example, the *speak* method referenced the *@name* instance variable, like this:

#+BEGIN_SRC ruby
  def speak
    "#{@name} says arf!"
  end
#+END_SRC

Here, we're referencing the *@name* instance variable, but it's usually better to call the /getter/ method instead. Because we have created the *name* getter method along with the *attr_accessor*, we can reference *name* rather than the instance variable (@name):

#+BEGIN_SRC ruby
  def speak
    "#{name} says arf!"
  end
#+END_SRC

Referencing the *getter* method allows us to keep our code simpler. This can make it easier do things like make changes, refactor, or obfuscate data.


