
+TITLE: Andrew's Tealeaf Lesson Two Notes
#+AUTHOR: Andrew Buckingham
#+STARTUP: indent
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
#+OPTIONS: ^:nil
#+TODO: TODO(t) | Started(s) | Waiting(w) | Canceled(c) | DONE(d)(@) | Questions(q) | Note(n)



* Assignment: Read OOP Tutorials
Assignment: Read OOP Tutorials

OOP is a huge topic, and we're trying to find the right balance of enough complexity so you can build a program, but not too much advanced topics to overwhelm. Review and do the exercises in the Object Oriented Programming section of our book: http://www.gotealeaf.com/books/oo_ruby

This book is still in "beta" mode, and we're treating it as a "living document" so don't be shy about suggestions or improvements!

Below are more tutorials around the internet that other students have found useful:

A nice quick overview on OOP in Ruby (you can skip the sections on freeze and allocate):

http://www.tutorialspoint.com/ruby/ruby_object_oriented.htm
Another short, but useful tutorial

part 1: http://zetcode.com/lang/rubytutorial/oop
part 2: http://zetcode.com/lang/rubytutorial/oop2
Codecademy's OOP track (look for the OO parts):

http://www.codecademy.com/tracks/ruby

* "Object Oriented Programming with Ruby"

** Objected Oriented Programming

*** Why Objected Oriented Programming? 
*The Object Model*
Objected-Oriented Programming (OOP) is a paradigm that allows developers to manipulate parts of a program, without causing errors throughout the rest of the program. It simplifies the process of creating complicated programs, by breaking a large codebase into many smaller and more manageable parts.

*Encapsulation* allows programmers to protect data by hiding functionality from accidental manipulation. In Ruby, this accomplished by creating objects and methods that act upon these objects.

*Polymorphism* is term that describes the way that data can be represented in different forms. One example of polymorphism in Ruby is in inheritance, where smaller *subclasses* inherit the behaviors of larger *superclasses*.

Another example is in the use of *modules*. Modules, like classes, contain shared behavior. But you cannot create an obect with a module. Modules must be /mixed in/ with classes, using the reserved word *include*. This is called a *mixin*. Once a module has been mixed in, module functionality is available to the class and its objects.

** What are Objects?
Rubyists often declare, "In Ruby, everything is an object!" Objects are declared from classes. If classes were molds, objects would be the things produced from the molds. Objects contain different data, but they are instances of the same class.

For example:

#+BEGIN_SRC ruby
irb :001 > "hello".class
=> String
irb :002 > "world".class
=> String
#+END_SRC

Both "hello" and "world" are objects in the *String* class.

** Classes Define Objects
In Ruby, attributes and behaviors of objects are defined in *classes*. The syntax for defining a class is similar to a method, with a few differences:
- Instead of *def*, class definitions begin with *class*.
- Class names use CamelCase.
- Class definites finish with *end*.
- Ruby File names use snake_case, and reflect the class name.

*Instantiation* is the process of creating a new object or instance from a class, like this:

#+BEGIN_SRC ruby
# good_dog.rb

class GoodDog
end

sparky = GoodDog.new

#+END_SRC

Note that the class method *new* returns an object.

#+BEGIN_SRC ditaa :file good_dog_objects.jpg

                          +-------------------+
                          |                   |
                          |                   |
                          |   GoodDog Class   |
                          |                   |
                          |                   |
                          +--------+----------+
                                   |
                                   |
            +----------------------+----------------------+
            |                      |                      |
  +---------+---------+   +--------+---------+   +--------+---------+
  |  GoodDog Object   |   | GoodDog Object   |   | GoodDog Object   |
  |      sparky       |   |      fido        |   |      spot        |
  |                   |   |                  |   |                  |
  |  @name = "Sparky" |   | @name = "Fido"   |   | @name = "Spot"   |
  |  @age = 4         |   | @age = 6         |   | @age = 10        |
  +-------------------+   +------------------+   +------------------+

#+END_SRC

** Modules
"A module is a collection of behaviors that is useable in other classes via mixins. A module is "mixed in" to a class using the include reserved word" ([[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model][Source]]).

Modules allow us to share behaviors between classes. For example:

#+BEGIN_SRC ruby :tangle good_dog.rb
  # good_dog.rb

  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  sparky = GoodDog.new
  sparky.speak("Arf!")
  bob = HumanBeing.new
  bob.speak("Hello!")

#+END_SRC

In this example, both the *GoodDog* and *HumanBeing* classes can access the *speak* method, because the *Speak* module was mixed in both of them.

** Method Lookup
Ruby has a method lookup path (or chain) that it follows whenever a method is called. To find the method chain for any class, use the *ancestors* method:

#+BEGIN_SRC ruby
  module Speak
    def speak(sound)
      puts "#{sound}"
    end
  end

  class GoodDog
    include Speak
  end

  class HumanBeing
    include Speak
  end

  puts "---GoodDog ancestors---"
  puts GoodDog.ancestors
  puts ' '
  puts "---HumanBeing ancestors---"
  puts HumanBeing.ancestors

#+END_SRC

Here is the output:

#+BEGIN_SRC ruby
---GoodDog ancestors---
GoodDog
Speak
Object
Kernel
BasicObject

---HumanBeing ancestors---
HumanBeing
Speak
Object
Kernel
BasicObject
#+END_SRC

As the [[http://www.gotealeaf.com/books/oo_ruby/read/the_object_model#modules][authors explain]]:

#+BEGIN_SRC markdown

The Speak module is placed right in between our custom classes (i.e., GoodDog and HumanBeing) and the Object class that comes with Ruby. In Inheritance you'll see how the method lookup chain works when working with both mixins and class inheritance.

This means that since the speak method is not defined in the GoodDog class, the next place it looks is the Speak module. This continues in an ordered, linear fashion, until the method is either found, or there are no more places to look.

#+END_SRC

** Exercises

*** Problem 1
How do we create an object in Ruby? Give an example of the creation of an object.

*** Solution 1
We create an object through the process of *instantiation*:

*file:* [[object_model/exercise1.rb]]
#+BEGIN_SRC ruby :tangle object_model/exercise1.rb
# object_model/exercise1.rb

class HumanBeing
end

human_object = HumanBeing.new

#+END_SRC

*** Authors' solution:
We create an object by defining a class and instantiating it by using the .new method to create an instance, also known as an object.

#+BEGIN_SRC ruby
class MyClass
end

my_obj = MyClass.new
#+END_SRC

*** Problem 2
What is a module? What is its purpose? How do we use them with our classes? Create a module for the class you created in exercise 1 and include it properly.

*File:* [[object_model/exercise2.md]]
*** Solution 2
#+BEGIN_SRC markdown :tangle object_model/exercise2.md
Modules allow programmers to encapsulate behaviors and mix them into classes. Modules encourage *polymorphism*, by allowing the same data to be reused in different places, in different forms.
#+END_SRC


*File:* [[object_model/exercise2.rb]]
#+BEGIN_SRC ruby :tangle object_model/exercise2.rb
  # object_model/exercise2.rb
    module Study
    end

    class MyClass
      include Study
    end

    my_obj = MyClass.new
#+END_SRC

**** COMMENT Authors' solution:

A module allows us to group reusable code into one place. We use modules in our classes by using the *include* reserved word, followed by the module name. Modules are also used as a namespace.



** Classes and Objects - Part 1

*** States and Behaviors
- We use classes to create objects.
- We usually focus on /states/ and /behaviors/.
- States track attributes for individual objects.
- Behaviors include anything that objects do.
- Instance variables store behaviors in classes, and states in objects.


Using the *GoodDog* class from before, we could create new *GoodDog* objects: "Fido" and "Sparky," each with different characteristics, like name, weight, age, or height. We can use *instance variables* to store these chracteristics.

*It's important to remember that instance variable are scoped at the object or instance level, and they are the mechanism for tracking object states.*

Because both "Fido" and "Sparky" are objects of the same *GoodDog* class, they share the same behaviors. For example, they can both run, bark, and fetch. These behaviors are stored as instance variable in the class, so they are available to all objects of that class (through inheritance).

*** Initializing a New Object
Using the same *GoodDog* class, we'll remove the old functionality and start over, by adding a new *initialize* method.

#+BEGIN_SRC ruby
  # good-dog.rb

  class GoodDog
    def initialize
      puts "This object was initilized!"
    end
  end

  sparky = GoodDog.new
#+END_SRC

The *initiliaze* method gets called every time we create a new object. As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]],
"In the above example, instantiating a new GoodDog object triggered the initialize method and resulted in the string being outputted. We refer to the initialize method as a constructor, because it gets triggered whenever we create a new object."

*** Instance Variables
The next example creates a new object and instantiates it with a new state (name).

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end
  end

#+END_SRC

The *@name* variable is an *instance variable*. Instance Varialbles:
- exists for as long as the object instance exists
- is a way to link data to objects
- does not "die" after the instance method is run
- *track information about the /state/ of an object*

In the example above, the initialize method takes a paramter, *name*. Using the *new* method to pass the argument *"Sparky"* through the initialize method, we can create a new object, using the *GoodDog* class we've just created:

#+BEGIN_SRC ruby
sparky = GoodDog.new("Sparky")
#+END_SRC

Within the constructor (i.e., the *initialize* method, the *@name* instance method is set to *name*, and the string "Sparky" is assigned to the *@name* instance variable.

In the example above, "Sparky" is the state of the @name instance variable. Another dog, like 'Fido' would indicate a different object state. Every object state is unique, and they are stored in instance variables.

*** Instance Methods
Let's give our *GoodDog* class more functionality:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak

#+END_SRC

We can also use string interpolation to change our *speak* method:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says Arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak

  fido = GoodDog.new("Fido")
  puts fido.speak
#+END_SRC

*** Accessor Methods

If we tried to print out only Sparky's name, we'd get a *NoMethodError: unefined method* error, which means that the method doesn't exist, or is not available to the object. For example: 

#+BEGIN_SRC ruby
puts sparky.name
#+END_SRC

But because the *name* method is not available to the *sparky* object, we'd get an error similar to this:

#+BEGIN_SRC ruby
NoMethodError: undefined method `name' for #<GoodDog:0x007f91821239d0 @name="Sparky">
#+END_SRC

As the authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][explain]], 

"If we want to access the object's name, which is stored in the @name instance variable, we have to create a method that will return the name. We can call it get_name, and its only job is to return the value in the @name instance variable."

#+BEGIN_SRC ruby
  #good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name

#+END_SRC

Now that we've added the *get_name* method, it should return the value of the *@name* instance variable.  

And here is the result:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
#+END_SRC

That worked, and we now have a /getter/ method. But what if, for example, we wanted to change *sparky*'s name? In that case, we'd need to use a /setter/ method:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    def intialize(name)
      @name = name
    end

    def get_name
      @name
    end

    def set_name=(name)
      @name = name
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.get_name
  sparky.set_name = "Spartacus"
  puts sparky.get_name

#+END_SRC

And the output would like like this:

#+BEGIN_SRC sh
Sparky says arf!
Sparky
Spartacus
#+END_SRC

Ruby provides special syntatical sugar for the /setter/ method. Instead of the "normal" syntax we might expect, 

#+BEGIN_SRC ruby
sparky.set_name=("Spartacus")

#+END_SRC

We can simply type:

#+BEGIN_SRC ruby
sparky.set_name = "Spartacus"
#+END_SRC

Rubyists usually want to set the /getter/ and /setter/ names to match the instance variables they expose/set. We can refactor our code to reflect this convention:

#+BEGIN_SRC ruby

  # good_dog.rb

  class GoodDog
    def initialize(name)
      @name = name
    end

    def name   # This was renamed from "get_name"
      @ name
    end

    def name=(n)  # This was renamed from "set_name"
      @name = n
    end

    def speak
      "#{@name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.name = "Spartacus"
  puts sparky.net  # => "Spartacus"

#+END_SRC

The /getter/ and /setter/ methods above take up a lot of room. And if we had more states to define, it would take even more code. Fortunately, Ruby has a built-in way to automatically create these /getter/ and /setter/ methods for us, using the *attr_accessor* method!

Here is an example, refactoring the example above:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    attr_accessor :name

    def initialize(name)
      @name = name
    end

    def speak
      "#{name} says arf!"
    end
  end

  sparky = GoodDog.new("Sparky")
  puts sparky.speak
  puts sparky.name  # => "Sparky"
  sparky.net = "Spartacus"
  puts sparky.name  # => "Spartacus"

#+END_SRC

The output for this program is the same! The *attr_accessor* method takes a symbol as an argument, and uses that to create the method name for the *getter* and *seter* methods. 

To create only a *getter* method, without the *setter* method, use *attr_reader* instead.

To create on a *setter* method, without the *getter* method, use the *attr_writer* method.

You can add as many states as you want to any of the *attr_** methods, by simply adding more symbols. For example:

#+BEGIN_SRC ruby
attr_accessor :name, :height, :weight
#+END_SRC

The authors [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part1#initializinganewobject][warn]]:
/Side note: Don't confuse this with attr_accessible, which is a Rails concept. attr_accessor is part of Ruby and exposes getter and setter methods for objects. attr_accessible is a Rails 3 and earlier way of white-listing attributes for mass-assignment; it has since been replaced by strong_parameters in Rails 4./

*** Accessor Methods in Action
The *getter* and *setter* methods provide us with a way to expose and change the state of an object. We can also use these methods within the class as well. 

In the previous example, the *speak* method referenced the *@name* instance variable, like this:

#+BEGIN_SRC ruby
  def speak
    "#{@name} says arf!"
  end
#+END_SRC

Here, we're referencing the *@name* instance variable, but it's usually better to call the /getter/ method instead. Because we have created the *name* getter method along with the *attr_accessor*, we can reference *name* rather than the instance variable (@name):

#+BEGIN_SRC ruby
  def speak
    "#{name} says arf!"
  end
#+END_SRC

Referencing the *getter* method allows us to keep our code simpler. This can make it easier do things like make changes, refactor, or obfuscate data.

If we were to add two more states to the GoodDog class, "height" and "weight":

#+BEGIN_SRC ruby
attr_accessor :name, :height, :weight
#+END_SRC

That one line of code provides us with: 
- Six getter/setter methods,
  1. *name*
  2. *name=*
  3. *height*
  4. *height=*
  5. *weight*
  6. *weight=*
- Three instance varibles:
  1. *@name*
  2. *@height*
  3. *@weight*

What if we wanted to create a new method, called *change_info(n, h, w)*, which allowed us to change several states at once, and we used each of the three states as arguments? 

We could implement it this way:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    @name = n
    @height = h
    @weight = w
  end
#+END_SRC

Our *GoodDog* class now looks like this:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      @name = n
      @height = h
      @weight = w
    end

    def speak
      "#{name} says arf!"
    end
    
    def change_info(n, h, w)
      @name = n
      @height = h
      @weight = w
    end

    def info
      "#{name} weighs #{weight} and is #{height} tall."
    end
  end
#+END_SRC

And we can use the *change_info* method this way:

#+BEGIN_SRC ruby
  sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
  puts sparky.info      # => Sparky weighs 10 lbs and is 12 inches tall.

  sparky.change_info('Spartacus', '24 inches', '45 lbs')
  puts sparky.info      # => Spartabus weights 10 lbs and is 24 inches tall.
#+END_SRC
Just as we've used getter methods to avoid accessing instance variables directly, we can use setter methods to do the same. However, there is a small 'gotcha' to watch for with setter methods...For example, we can refactor the *change_info* method from above:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    name = n
    height= h
    weight = w
  end
#+END_SRC
But when we run it, nothing changes!

#+BEGIN_SRC ruby
  sparky.change_info('Spartacus', '24 inches', '45 lbs')
  puts sparky.info      # => Sparky weighs 10 lbs and is 12 inches tall.
#+END_SRC

*The reason nothing changed is that Ruby thought we were instantiating local variables!* In other words, instead of calling the *name=*, *height=*, and *weight=* setter methods, we created three new local variable: *name*, *height*, and *weight*.

To make it clear that we are not calling a local variable, we can use *self.name=* to show that we are calling a method. So we can now update our *change_info* code:

#+BEGIN_SRC ruby
  def change_info(n, h, w)
    self.name = n
    self.height = h
    self.weight = w
  end
#+END_SRC

This makes it clear that we are calling a setter method, and not creating a local variable. To be consistent, we could use the same syntax for the getter methods, but it is not necessary.

#+BEGIN_SRC ruby
  def info
    "#{self.name} weighs #{self.weight} and is #{self.height} tall."
  end
#+END_SRC

You can use the *self* prefix with any instance method; not just the accessor methods. For example, *info* is not a method included in *attr_accessor*, but we can call it with *self.info*:

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog
    # ... preceding code ommited ...
    def some_method
      self.info
    end
  end
#+END_SRC

** Exercises

*** Exercise 1
Create a class called MyCar. When you initialize a new instance or object of the class, allow the user to define some instance variables that tell us the year, color, and model of the car. Create an instance variable that is set to 0 during instantiation of the object to track the current speed of the car as well. Create instance methods that allow the car to speed up, brake, and shut the car off.

*File:* [[classes_and_objects_1/exercise1.rb]]
*** Solution 1
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise1.rb
  # classes_and_objects_1/exercise1.rb

  class MyCar
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  civic = MyCar.new(2014, 'honda civic', 'brown')
  civic.speed_up(20)
  civic.current_speed
  civic.speed_up(20)
  civic.current_speed
  civic.brake(20)
  civic.current_speed
  civic.brake(20)
  civic.current_speed
  civic.shut_down
  civic.current_speed
#+END_SRC

*** Exercise 2
Add an accessor method to your MyCar class to change and view the color of your car. Then add an accessor method that allows you to view, but not modify, the year of your car.

*** Solution 2
*File:* classes_and_objects_1/exercise2.rb
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise2.rb

  class MyCar

    attr_accessor :color
    attr_reader :year

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  civic = MyCar.new(2014, 'honda civic', 'brown')
  puts civic.color
  civic.color = "blue"
  puts civic.color
  puts civic.year

#+END_SRC

*** Exercise 3
You want to create a nice interface that allows you to accurately describe the action you want your program to perform. Create a method called *spray_paint* that can be called on an object and will modify the color of the car.

*** Solution 3
*File:* classes_and_objects_1/exercise3.rb
#+BEGIN_SRC ruby :tangle classes_and_objects_1/exercise3.rb
    class MyCar

      attr_accessor :color
      attr_reader :year

      def initialize(year, model, color)
        @year = year
        @model = model
        @color = color
        @current_speed = 0
      end

      def speed_up(number)
        @current_speed += number
        puts "You hit the gas and accelerate #{number} MPH."
      end

      def brake(number)
        @current_speed -= number
        puts "You hit the brakes and slow down #{number} MPH."
      end

      def current_speed
        puts "You're now going #{current_speed} MPH."
      end

      def shut_down
        @current_speed = 0
        puts "Let's park!"
      end

      def spray_paint(color)
        self.color = color
        puts "You painted your car #{color}? It looks like new!"
      end
    end

    civic = MyCar.new(2014, 'honda civic', 'brown')
    civic.spray_paint('blue')
#+END_SRC

And here's the result:
#+BEGIN_SRC sh
小A曰:ruby exercise3.rb
You painted your car blue? It looks like new!
#+END_SRC

** Classes and Objects II

*** Class Methods
Until now, all of the methods we've created have been instance methods. These methods relate to the instance or object of a class. *Class methods* can be called directly on the class itself, without needing to be instatiated first. 

When we define a class method, we prepend the method name with the reserved word *self*.

For example:

#+BEGIN_SRC ruby
  # good_dog.rb
  # ... the the rest of the code has been ommitted

  def  self.what_am_i    # Class method definition
    "I'm a GoodDog class!"
  end
#+END_SRC

To call a class method, we can prepend the name of the class to the method, without instantiating any objects, like this:

#+BEGIN_SRC ruby
GoodDog.what_am_i    # => I'm a GoodDog class!
#+END_SRC

Class methods are useful in situations where we want to add functonality that is not related to individual objects. Because objects have states, if we have a method that does not need to deal with states, we can simply use a class method. We'll see more practical examples in the next section.

*** Class Variables

In the same way that instance variables capture information and behaviors related to specific instances of classes (i.e., objects), *class variables* perform the same duties for entire classes.

To create a class variable, preceded the variable name with *@@*.

#+BEGIN_SRC ruby
  class GoodDog
    @@number_of_dogs = 0

    def initialize
      @@ number_of_dogs += 1
    end

    def self.total_number_of_dogs
      @@number_of_dogs
    end
  end

  puts GoodDog.total_number_of_dogs   # => 0

  dog1 = GoodDog.new
  dog2 = GoodDog.new

  puts GoodDog.total_number_of_dogs   # => 2
#+END_SRC

Here's a description of what's happening:
- *@@number_of_dogs* is a class variable, initialized to 0.
- *@@number_of_dogs* is incremented by 1 via the contructor (the *initialize* method).
- Every time we instantiate a new method (e.g., 'dog1 = GoodDog.new'), *initialize* is called. (Note that *initialize* is an instance method, and class methods can be called within instance methods).
- We return the value of the class variable in the class method *self.totla_number_of_dogs* (we use a class variable and a class method to track class-level details that pertain to class, and not to individual objects).

*** Constants
Predictably, class contants are variables that never change, and are defined with a capital letter at the beginning of the variable name. Rubyists usually capitalize the whole word, but only the first letter is mandatory.

#+BEGIN_SRC ruby
  class GoodDog
    DOG_YEARS = 7

    attr_accessor :name, :age

    def initialize(n, a)
      self.name = n
      self.age = a * DOG_YEARS
    end
  end

  sparky = GoodDog.new("Sparky", 4)
  puts sparky.age             # => 28
#+END_SRC

Here's what's happening:
1. The *DOG_YEARS* constant calculates the age of the object *sparky* in dog years.
2. The *attr_accessor* method provides the *@name* and *@age* instance methods, and provides corresponding /getter/ and /setter/ methods.
3. The *initialize* method's /setter/ method allows us to initialize the instance methods.
4. the *age* getter method allows us to retrive the objects's value.

*** The to_s Method

Using the built-in *to_s* method to inspect the *sparky* object that we've just created, we might get something like this:

#+BEGIN_SRC ruby
puts sparky      # => #<GoodDog:0x007fe542323320>
#+END_SRC

Because the *puts* method automatically calls *to_s* on its argument, the output here is the same as *puts sparky.to_s*.

We can test this by creating a custom *to_s* method on the *GoodDog* class to override the built-in method.

#+BEGIN_SRC ruby

  class GoodDog
    DOG_YEARS = 7

    attr_accessor :name, :age

    def initialize(n, a)
      self.name = n
      self.age = a * DOG_YEARS
    end

    def to_s
      "This dog's name is #{name} and it is #{age} in dog years."
    end
  end
#+END_SRC

The output has now changed:

#+BEGIN_SRC ruby
puts sparky      # => This dog's name is Sparky and is 28 in dog years.
#+END_SRC

The *to_s* method:
- is automatically called when using *puts*
- is automatically called in string interpolation

For example:

#+BEGIN_SRC sh
irb(main):001:0> array = [1, 2, 3]
array = [1, 2, 3]
=> [1, 2, 3]
irb(main):002:0> x = 5
x = 5
=> 5
irb(main):003:0> "The #{array} array doesn't include #{x}."
"The #{array} array doesn't include #{x}."
=> "The [1, 2, 3] array doesn't include 5."
#+END_SRC

What if we try to use string interpolation on the *sparky* object?

#+BEGIN_SRC sh
irb(main):004:0> "#{sparky}"
=> "This dog's name is Sparky and is 28 in dog years."
#+END_SRC

*Knowing that to_s is called when using puts or for string interpolation is very important for understanding and writing better OO code.*

*** More about self

*self* helps us designate a certain scope for our program. It can mean different things, in different contexts. According to the [[http://www.gotealeaf.com/books/oo_ruby/read/classes_and_objects_part2][authors]]:

For example, so far we've seen two clear use cases for self:

    Use *self* when calling setter methods from within the class. In our earlier example we showed that *self* was necessary in order for our *change_info* method to work properly. We had to use *self* to allow Ruby to disambiguate between initializing a local variable and calling a setter method. While not required, it's also a good idea to prepend *self* when calling all instance methods from within the class, not only for setter methods.

    Use *self* for class method definitions.

We can test this out:
#+BEGIN_SRC ruby
  class GoodDog
    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def change_info(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def info
      "#{self.name} weighs #{self.weight} and is #{self.height} tall."
    end
  end
#+END_SRC

We're using *self* whenever we call an instance method from within the class. But what exactly does *self* represent? To find out, we can add another instance method...

#+BEGIN_SRC ruby
  # good_dog.rb

  class GoodDog

    attr_accessor :name, :height, :weight

    def initialize(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def change_info(n, h, w)
      self.name = n
      self.height = h
      self.weight = w
    end

    def info
      "#{self.name} weighs #{self.weight} and is #{self.height} tall."
    end

    def what_is_self
      self
    end
  end
#+END_SRC

And if we instantiate a new *GoodDog* object and inspect it:

#+BEGIN_SRC ruby
irb(main):029:0> sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
sparky = GoodDog.new('Sparky', '12 inches', '10 lbs')
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

irb(main):030:0> p sparky
p sparky
#<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

irb(main):031:0> puts sparky
puts sparky
#<GoodDog:0x007fdc73264448>
=> nil

irb(main):032:0> p sparky.what_is_self
p sparky.what_is_self
#<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">
=> #<GoodDog:0x007fdc73264448 @name="Sparky", @height="12 inches", @weight="10 lbs">

#+END_SRC

From within a class, when an instance method calls *self*, it returns the /calling method/, which in this case is the *sparky* object. From within the *change_info* method, calling *self.name=* is the same as calling *sparky.name=*. 

We also use the *self* method to define class methods:

#+BEGIN_SRC ruby
  class MyAwesomeClass
    def self.this_is_a_class_method
    end
  end
#+END_SRC

*self*, when inside a class but outside an instance method, actually refers to the class itself. So prefixing a method definition with *self* is the same as defining a method on the class. (i.e., *def self.a_method* == *def GoodDog.a_method*)

Within a class:

1. Inside instance methods, *self* references the calling object (the instance/object that called the method). *self.weight=* is equivalent to *sparky.weight=* in the example above.
2. Outside instance methods, *self* references the class, and can define class mehods. *def self.name=(n)* euivalent to *def GoodDog.name=(n)* in the example above.

Self allows us to explicitly reference things, as well as reveal the intended behavior. It's very important to pay attention to whether *self* is in an instance method or not, as it changes meaning, based on scope.

** Exercises

*** Exercise 1
Add a class method to your MyCar class that calculates the gas mileage of any car.

*** Solution 1
*File:* [[classes_and_objects_2/exercise1.rb]]
#+BEGIN_SRC ruby :tangle classes_and_objects_2/exercise1.rb
# classes_and_objects_2/exercise1.rb

  class MyCar

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  MyCar.gas_mileage(11, 389) # => "35 miles per gallon"
#+END_SRC

*** Exercise 2
Override the to_s method to create a user friendly print out of your object.

*** Solution 2
*File:* [[classes_and_objects_2/exercise2.rb]]
#+BEGIN_SRC ruby :tangle classes_and_objects_2/exercise2.rb
  # classes_and_objects_2/exercise2.rb

  class MyCar

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
    
    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  civic = MyCar.new("2014", "Honda Civic", "brown"}
  puts civic # => "My car is a brown, 2014, Honda Civic."
#+END_SRC

*** Exercise 3
When running the following code...

#+BEGIN_SRC ruby
  class Person
    attr_reader :name
    def initialize(name)
      @name = name
    end
  end

  bob = Person.new("Steve")
  bob.name = "Bob"
#+END_SRC

We get the following error...

#+BEGIN_SRC ruby
test.rb:9:in `<main>': undefined method `name=' for
  #<Person:0x007fef41838a28 @name="Steve"> (NoMethodError)
#+END_SRC

Why do we get this error and how to we fix it?

*** Solution 3
*File:* [[classes_and_objects_2/exercise3.md]]
#+BEGIN_SRC markdown :tangle classes_and_objects_2/exercise3.md
We get the error because the program use **attr_reader**, which creates a getter method, but not a setter method. But at the end, the program tries to set Bob's name.

To fix this, change **attr_reader** to **attr_writer** if you don't need the getter method, or set it to **attr_accessor** if you'd like to have both a getter and a setter method for the @name instance variable.
#+END_SRC

** Inheritance

Inheritance allows us to extract shared behavior from classes, and move it to a superclass. Inheritance allows us to keep our logic in one place, which makes our code better organized.

*** Class Inheritance
Extracting the *speak* method from the *GoodDog* class into a new *Animal* class allows us to make that behavior available to both the *GoodDog* and *Cat* classes.

#+BEGIN_SRC ruby
  # good_dog_class.rb

  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
  end

  class Cat < Animal
  end

  sparky = GoodDog.new
  paws = Cat.new
  puts spark.speak      # => Hello!
  puts paws.speak       # => Hello!

#+END_SRC

Both the *Cat* and *GoodDog* classes inherit the *speak* method. But we can override the speak method in subclasses. For example, we can add the original *speak* method back into *GoodDog*:

#+BEGIN_SRC ruby
  # good_dog_class.rb

  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
    attr_accessor :name

    def initialize(n)
      self.name = n
    end

    def speak
      "#{self.name} says arf!"
    end
  end

  class Cat < Animal
  end

  sparky = GoodDog.new("Sparky")
  paws = Cat.new

  puts sparky.speak       # => Sparky says arf!
  puts paws.speak         # => Hello!
#+END_SRC

*** super

*super* is a built-in function in ruby that allows us to call methods up the inheritance hierarchy. By calling *super* from inside a method, you instruct Ruby to search the inheritance hierarchy for a method of the same name. When it finds it, it invokes it. Here's an example:

#+BEGIN_SRC ruby
  class Animal
    def speak
      "Hello!"
    end
  end

  class GoodDog < Animal
    def speak
      super + " from GoodDog class"
    end
  end

  spearky = GoodDog.new
  sparky.speak           # => "Hello! from GoodDog class"
#+END_SRC


In this case, invoking *super* in the *GoodDog* class  allows us to call the *speak* class from the superclass (*Animal*), and then append a new string.

Another common way to use *super* is with *initialize*. For example:

#+BEGIN_SRC ruby
  class Animal
    attr_accessor :name

    def initialize(name)
      @name = name
    end
  end

  class GoodDog < Animal
    def initialize(color)
      super
      @color = color
    end
  end

  bruno = GoodDog.new("brown")       => #<GoodDog:0x007fb40b1e6718 @color="brown", @name="brown">
#+END_SRC
In this example, using *super* allows us to forward the arguments from the class where its called (the subclass) up to the superclass and invoke them.


When *super* is called with arguments, the arguments are passed up the method lookup chain:

#+BEGIN_SRC ruby
  class BadDog < Animal
    def initialize(age, name)
      super(name)
      @age = age
    end
  end

  BadDog.new(2, "bear")   => #<BadDog:0x007fb40b2beb68 @age=2, @name="bear">
#+END_SRC

In this example, argument *name* is passed by up to the superclass and set to the *@name* instance variable.

*** Mixing in Modules
Modules offer another way to follow the DRY principle in Ruby.

By extracting common methods to a superclass, we can simplify our code and model concepts that follow a natural hierarchy. For example, we can extract the shared, common behavior of the *Cat* and *Dog* classes we've made into a new *Mammal* class, and add a *Fish* class outside the mammal class:

#+BEGIN_SRC ditaa :file inheritance/animal_classes.png :cmdline -r
            +----------+
            |  Animal  |
            +----++----+
                 ||             
       +---------/\-----------+     
       |                      |     
  +----+----+            +----+---+ 
  |  Fish   |            | Mammal |     
  +---------+            +---+-+--+ 
                             | |    
                             | |    
                             | |    
                 +-------+   | |   +-------+
                 |  Cat  +---/ \---+  Dog  |
                 +-------+         +-------+

#+END_SRC

However, as our programs grow in complexity, we face a new problem. We don't want to repeat our code in different classes, but when some subclasses do not share the same behavior, we cannot add it to the superclass.

Modules provide a way to abstract behavior, which can then be mixed in to the appropriate classes. Taking the example above, if we wanted to add in a *swim* method to the *Fish* and *Dog* classes only, we could create a module, and add them to those classes, like this:

#+BEGIN_SRC ruby
  module Swimmable
    def swim
      "I'm swimming!"
    end
  end

  class Animal; end

  class Fish < Animal
    include Swimmable          # mixing in the Swimmable module
  end

  class Mammal < Animal
  end

  class Cat < Mammal
  end

  class Dog < Mammal
    include Swimmable          # mixing in the Swimmable module
  end
#+END_SRC

Result:
#+BEGIN_SRC ruby
sparky = Dog.new
neemo  = Fish.new
paws   = Cat.new

sparky.swim                 # => I'm swimming!
neemo.swim                  # => I'm swimming!
paws.swim                   # => NoMethodError: undefined method `swim' for 

#<Cat:0x007fc453152308>
#+END_SRC


/Note: using the prefix '~able' to describe actions, as in the 'Swimmable' example above, is a common Ruby convention./

*** Inheritance vs. Modules

Here are some guidelines for choosing between inheritance and modules:

- Classes can only be the subclass of one superclass. But you can mix in as many modules as you want.
- For 'is-a' relationshiops: choose class inheritance. For 'has-a' relationship, modules are the better choice. For example: a dog 'is an' animal (class inheritance; Dog < Animal), and a dog "has an" ability to swim (Swimmable module).
- Modules can't be instantiated, so they cannot be used to create objects. Modules are only used for namespacing and grouping common methods together.

*** Method Lookup Path
We can use inheritance and mixins to view the hierarchy of classes are looked up when a method is called:

#+BEGIN_SRC ruby
  module Walkable
    def walk
      "I'm walking."
    end
  end

  module Swimmable
    def swim
      "I'm swimming."
    end
  end

  module Climbable
    def climb
      "I'm climbing."
    end
  end

  class Animal
    include Walkable

    def speak
      "I'm an animal, and I speak!"
    end
  end
#+END_SRC

There are three modules and one class here. One of the modules (*Walkable*) has been mixed into the *Animal* class. We can use the *ancestors* class method to trace the method lookup path:

#+BEGIN_SRC ruby
puts "---Animal method lookup---"
puts Animal.ancestors
#+END_SRC

Here's the output:

#+BEGIN_SRC sh
---Animal method lookup---
Animal
Walkable
Object
Kernel
BasicObject
#+END_SRC

When Ruby finds the appropriate method in the current class, it looks no futher:

#+BEGIN_SRC ruby
fido = Animal.new
fido.speak                  # => I'm an animal, and I speak!
#+END_SRC

If the method is not found in the current class, it will go up the chain, until it finds the method, and execute it.

#+BEGIN_SRC ruby
fido.walk                   # => I'm walking.
#+END_SRC

If Ruby traverses all the classes and modules in the method lookup list, and doesn't find it, it throws an error:

#+BEGIN_SRC ruby
fido.swim
  # => NoMethodError: undefined method `swim' for #<Animal:0x007f92832625b0>
#+END_SRC

What if we add another class, that inherits from the *Animal* class, and mixes in the *Swimmable* and *Climbable* modules?

#+BEGIN_SRC ruby
  class GoodDog < Animal
    include Swimmable
    include Climbable
  end

puts "---GoodDog method lookup---"
puts GoodDog.ancestors
#+END_SRC

Here's the output:

#+BEGIN_SRC sh
---GoodDog method lookup---
GoodDog
Climbable
Swimmable
Animal
Walkable
Object
Kernel
BasicObject
#+END_SRC

A few things to note about the output:
- The order in which we include modules is important. Ruby looks at the last module included /first/. (If we included two or more modules with methods that had the same name, the last module included would be referenced first.)
- The moduled included in the superclass made it into the method lookup path. (Thus, all *GoodDog* objects will have access to *Walkable* and any other modules mixed in to its superclasses, in addition the *Animal* superclass.)
- Understanding the method lookup list is essential for large, complicated projects.

*** More Modules
In addtiton to allowing us to mix shared behavior into classes, modules can be used for two other purposes:

1. Namespacing
2. Module Methods (i.e., containers for methods)

**** Namespacing
Namespacing allows us to organize similar classes under a module. Not only does this make it easier to recognize related classes in our code, but it lowers the chances of having similarly named classes collide in our code.

Here's how it works:

#+BEGIN_SRC ruby
  class Mammal
    class Dog
      def speak(sound)
        p "#{sound}"
      end
    end

    class Cat
      def say_name(name)
        p "#{name}"
      end
    end  
#+END_SRC

You can call classes in a module by appending the class name to the module name with two colons (::)

#+BEGIN_SRC ruby
  buddy = Mammal::Dog.new
  kitty = Mammal::Cat.new
  buddy.speak('Arf!')          # => "Arf!"
  kitty.say_name('kitty')      # => "kitty"
#+END_SRC

Modules can also serve as *containers* for methods, called *module methods*. Using modules to house methods can be very useful for methods that don't seem to fit anywhere else within the code. 

For example:

#+BEGIN_SRC ruby
  module Mammal
    class Dog
      def speak(sound)
        p "#{sound}"
      end
    end

    class Cat
      def say_name(name)
        p "#{name}"
      end
    end

    # adding a module method:

    def self.some_out_of_place_method(num)
      num ** 2
    end
  end
#+END_SRC

Modules methods can be called directly from the module:

#+BEGIN_SRC ruby
value - Mammal.some_out_of_place_method(4)
#+END_SRC

Or they can be called with double colons:

#+BEGIN_SRC ruby
value = Mammal::some_out_of_place_method(4)
#+END_SRC

Though both are possible, the former method (calling them directly) is the perferred way.

*** Private, Protected, and Public
*Public Methods* 
- Are available to anyone who knows either the class name or the objects name.
- Available for the rest of the program to uses, and comprise the class's /interface/ with other classes and objects.

*Private Methods*
- Work within the class, but don't need to be available to the rest of the program.
- Defined with the reserved word *private*. Everything below this word is private, unless negated by another reserved word.

Looking at the *GoodDog* class we've made, the *Dog Years* method could be moved into private method, to protect it from being used by other classes (Measuring dog years for a fish wouldn't make most sense, in mose cases!).

We can refactor the logic:

#+BEGIN_SRC ruby
  class GoodDog
    DOG_YEARS = 7

    attr_accessor :name, :age

    def initialize(n, a)
      self.name = n
      self.age = a * DOG_YEARS
    end

    private

    def human_years
      self.age / DOG_YEARS
    end
  end

  sparky = GoodDog.new("Sparky", 4)
  sparky.human_years
#+END_SRC

This produces the following error message:

#+BEGIN_SRC sh
NoMethodError: private method `human_years' called for
  #<GoodDog:0x007f8f431441f8 @name="Sparky", @age=28>
#+END_SRC

The *human_years* method is private, but we couldn't call it here, because private methods can only be accessed by other methods in the class (i.e., it can't be called by an object, like 'sparky' in the example above). Private methods are invoked by other methods in the same class. For example:

#+BEGIN_SRC ruby
  # assume the method definition below is above the "private" keyword

  def public_disclosure
    "#{self.name} in human years is #{human_years}"
  end
#+END_SRC

*Keypoints:*
- We cannot use *self.human_years*, because *human_years* is a private class, and private classes can only be invoked by other methods in the same class. (*self.human_years* == *sparky.human_years*. Objects can't access private methods.
- We can only use *human_years*. (Private methods are only accessible within the class, when called without *self*.

*** Protected Methods
Although public and private methods are most common, protected methods provide an "in-between" approach, which can be useful in some cases. 

*Keypoints:*
- Protected methods are designated by the *protected* keyword, just as *private* designates private methods.
- From /outside/ the class, *protected* methods act the same as *private* methods.
- From /inside/ the class, *protected* methods can be accessed just like *public* methods.

Examples:

#+BEGIN_SRC ruby
  class Animal
    def a_public_method
      "Will this work? " + self.a_protected_method
    end

    protected

    def a_protected_method
      "Yes, I'm protected!"
    end
  end
#+END_SRC

When we test it, it works:

#+BEGIN_SRC ruby
fido = Animal.new
fido.a_public_method        # => Will this work? Yes, I'm protected!
#+END_SRC

So we can call a *protected* method from within the class, even when prepended with *self*.

However, if we try this outside of the class, Ruby throws an error:

#+BEGIN_SRC ruby
  fido.a_protected_method
  # => NoMethodError: protected method `a_protected_method' called for
  #<Animal:0x007fb174157110>
#+END_SRC

Remember that we can't call protected methods from outside the class, per the second rule. These rules apply within the context of inheritance, as well.

*** Accidental Method Overriding
Because every class we create in Ruby is a subclass of the *Object* class, every class inherits many critical, built-in methods.

#+BEGIN_SRC ruby
  class Parent
    def say_hi
      p "Hi from Parent."
    end
  end

  parent.superclass            # => Object
#+END_SRC

But it also means that a subclass method can override a superclass's method.

#+BEGIN_SRC ruby
  class Child < Parent
    def say_hi
      p "Hi from Child."
    end
  end

  child = Child.new
  child.say_hi                 # => "Hi from Child."
#+END_SRC

Accidentally overriding *Object* methods can cause serious problems. For example, the *send* instance method is inherited from all classes that inherit from *Object*. If you were to define a new *send* method in a subclass, it would override the built-in *send* class.

The Object *send* method provides a means to call a method, by passing it a symbol or string, which represents the method you want to call. 

Let's see how *send* normally works:

#+BEGIN_SRC ruby
  son = Child.new
  son.send :say_hi     # => "Hi from Child."
#+END_SRC

Now, let's define a new send method, and invoke it:

#+BEGIN_SRC ruby
  class Child
    def say_hi
      p "Hi from Child."
    end

    def send
      p "send from Child..."
    end

  end

  lad = Child.new
  lad.send :say_hi
#+END_SRC

As we saw in the previous example, using *Object* send, we'd expect to see the output, "Hi from Child." But actually, we get:

#+BEGIN_SRC sh
  ArgumentError: wrong number of arguments (1 for 0)
  from (pry):12:in `send'
#+END_SRC

Note that we're passing an argument to *send*, even though our overriden *send* subclass method does not take any arguments.


Another example...

Object's *instance_of? method returns *true* if an object is an instance of a given class, and *false* if it is not. Here's how it works:

#+BEGIN_SRC ruby
  c = Child.new
  c.instance.of? Child     # => true
  c.instance.of? Parent    # => false
#+END_SRC

And if we override *instance_of?* within *Child*:

#+BEGIN_SRC ruby
  class Child
    # other methods omitted

    def instance_of?
      p "I am a fake instance"
    end
  end

  heir = Child.new
  heir.instance_of? Child
#+END_SRC

And once again, we get a nasty surprise when we try to call Object's *instance_of?* method:

#+BEGIN_SRC sh
  ArgumentError: wrong number of arguments (1 for 0)
  from (pry):22:in `instance_of?'
#+END_SRC

The one *Object* instance method that is easily overriden, without major side effects, is the *to_s* method. Overriding it can be useful when you want a different string representation of an object.

It's a good idea to become familiar with common *Object* methods, so that you don't accidentally override them.

** Exercises

*** Exercise 1
Create a superclass called Vehicle for your MyCar class to inherit from and move the behavior that isn't specific to the MyCar class to the superclass. Create a constant in your MyCar class that stores information about the vehicle that makes it different from other types of Vehicles.

Then create a new class called MyTruck that inherits from your superclass that also has a constant defined that separates it from the MyCar class in some way.

*** Solution 1
*File*: [[inheritance/exercise1.rb]]
#+BEGIN_SRC ruby :tangle inheritance/exercise1.rb
  # inheritance/exercise1.rb
  class Vehicle
    attr_accessor :color
    attr_reader :year
    attr_reader :model

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
    end

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} MPG"
    end

    def speed_up(number)
      @current_speed += number
      puts "You push the gas and accelerate #{number} MPH."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  class MyCar < Vehicle
    NUMBER_OF_DOORS = 4

    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  class MyTruck < Vehicle
    NUMBER_OF_DOORS = 2

    def to_s
      "My truck is a #{self.color}, #{self.year}, #{@model}."
    end
#+END_SRC

*** Exercise 2
Add a class variable to your superclass that can keep track of the number of objects created that inherit from the superclass. Create a method to print out the value of this class variable as well.

*** Solution 2
*File*: [[inheritance/exercise2.rb]]
#+BEGIN_SRC ruby :tangle inheritance/exercise2.rb
    # inheritance/exercise2.rb
    class Vehicle
      @@number_of_vehicles = 0

      def self.number_of_vehicles
        puts "You have #{@@number_of_vehicles} vehicles."
      end
      
      attr_accessor :color
      attr_reader :year
      attr_reader :model

      def initialize(year, model, color)
        @year = year
        @model = model
        @color = color
        @current_speed = 0
        @@number_of_vehicles += 1
      end

      def self.gas_mileage(gallons, miles)
        puts "#{miles / gallons} MPG"
      end

      def speed_up(number)
        @current_speed += number
        puts "You push the gas and accelerate #{number} MPH."
      end

      def brake(number)
        @current_speed -= number
        puts "You hit the brakes and slow down #{number} MPH."
      end

      def current_speed
        puts "You're now going #{current_speed} MPH."
      end

      def shut_down
        @current_speed = 0
        puts "Let's park!"
      end
    end

    class MyCar < Vehicle
      NUMBER_OF_DOORS = 4

      def to_s
        "My car is a #{self.color}, #{self.year}, #{@model}."
      end
    end

    class MyTruck < Vehicle
      NUMBER_OF_DOORS = 2

      def to_s
        "My truck is a #{self.color}, #{self.year}, #{@model}."
      end
    end

    car = MyCar.new('2014', "Honda Civic", "brown")
    truck = MyTruck.new('2012', "Ford F150", "blue")

    puts car
    puts truck
    puts Vehicle.number_of_vehicles
#+END_SRC

Output:
#+BEGIN_SRC sh
小A曰:ruby exercise2.rb
My car is a brown, 2014, Honda Civic.
My truck is a blue, 2012, Ford F150.
You have 2 vehicles.
#+END_SRC

*** Exercise 3
Create a module that you can mix in to ONE of your subclasses that describes a behavior unique to that subclass.

*** Solution 3
*File:* [[inheritance/exercise3.rb]]
#+BEGIN_SRC ruby :tangle inheritance/exercise3.rb
  # inheritance/exercise3.rb
  module Haulable
    def can_haul?(pounds)
      pounds < 2000 ? true : false
    end
  end

  class Vehicle
    @@number_of_vehicles = 0

    def self.number_of_vehicles
      puts "This program has created #{@@number_of_vehicles} vehicles."
    end

    attr_accessor :color
    attr_reader :year
    attr_reader :model

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
      @@number_of_vehicles += 1
    end

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} mph."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  class MyCar < Vehicle
    NUMBER_OF_DOORS = 4

    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  class MyTruck < Vehicle
    include Haulable

    NUMBER_OF_DOORS = 2

    def to_s
      "My truck is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  car = MyCar.new('2014', "Honda Civic", "brown")
  truck = MyTruck.new('2012', "Ford F150", "blue")

  puts car
  puts truck
  puts Vehicle.number_of_vehicles
#+END_SRC

*** Exercise 4
Print to the screen your method lookup for the classes that you have created.

*** Solution 4
*File:* [[inheritance/exercise4.rb]]
#+BEGIN_SRC ruby :tangle inheritance/exercise4.rb
  # inheritance/exercise4.rb 
  # "Print to the screen the method lookup for the classes that you have created."

  module Haulable
    def can_haul?(pounds)
      pounds < 2000 ? true : false
    end
  end

  class Vehicle
    @@number_of_vehicles = 0

    def self.number_of_vehicles
      puts "This program has created #{@@number_of_vehicles} vehicles."
    end

    attr_accessor :color
    attr_reader :year
    attr_reader :model

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
      @@number_of_vehicles += 1
    end

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} mph."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  class MyCar < Vehicle
    NUMBER_OF_DOORS = 4

    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  class MyTruck < Vehicle
    include Haulable

    NUMBER_OF_DOORS = 2

    def to_s
      "My truck is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  car = MyCar.new('2014', "Honda Civic", "brown")
  truck = MyTruck.new('2012', "Ford F150", "blue")

  puts car
  puts truck
  puts Vehicle.number_of_vehicles
  puts "===="
  puts "  "
  # Class Method Lookup
  puts "'Vehicle' method lookup"
  puts Vehicle.ancestors
  puts "======"
  puts "'MyCar' method lookup"
  puts MyCar.ancestors
  puts "======"
  puts "'MyTruck' method lookup"
  puts MyTruck.ancestors
#+END_SRC

*** Exercise 5
Move all of the methods from the MyCar class that also pertain to the MyTruck class into the Vehicle class. Make sure that all of your previous method calls are working when you are finished.

*** Solution 5
*File:* [[inheritance/exercise5.rb]]

#+BEGIN_SRC ruby :tangle inheritance/exercise5.rb
  # inheritance/exercise5.rb 

  # Move all MyCar methods that pertain to the MyTruck class into the Vehicle Class

  module Haulable
    def can_haul?(pounds)
      pounds < 2000 ? true : false
    end
  end

  class Vehicle
    @@number_of_vehicles = 0

    def self.number_of_vehicles
      puts "This program has created #{@@number_of_vehicles} vehicles."
    end

    attr_accessor :color
    attr_reader :year
    attr_reader :model

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
      @@number_of_vehicles += 1
    end

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} mph."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end
  end

  class MyCar < Vehicle
    NUMBER_OF_DOORS = 4

    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  class MyTruck < Vehicle
    include Haulable

    NUMBER_OF_DOORS = 2

    def to_s
      "My truck is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  car = MyCar.new('2014', "Honda Civic", "brown")
  truck = MyTruck.new('2012', "Ford F150", "blue")

  puts car
  puts truck
  puts Vehicle.number_of_vehicles
  puts "===="
  puts "  "
  # Class Method Lookup
  puts "'Vehicle' method lookup"
  puts Vehicle.ancestors
  puts "======"
  puts "'MyCar' method lookup"
  puts MyCar.ancestors
  puts "======"
  puts "'MyTruck' method lookup"
  puts MyTruck.ancestors
#+END_SRC

I had already done this, actually. :)

*** Exercise 6
Write a method called age that calls a private method to calculate the *age* of the vehicle. Make sure the private method is not available from outside of the class. You'll need to use Ruby's built-in *Time* class to help.

*** Solution 6
*File:* inheritance/exercise6.rb
#+BEGIN_SRC ruby :tangle inheritance/exercise6.rb
  # inheritance/exercise6.rb

  # Write a private method call 'age' that calculates the age of the vehicle.

  module Haulable
    def can_haul?(pounds)
      pounds < 2000 ? true : false
    end
  end

  class Vehicle
    @@number_of_vehicles = 0

    def self.number_of_vehicles
      puts "This program has created #{@@number_of_vehicles} vehicles."
    end

    attr_accessor :color
    attr_reader :year
    attr_reader :model

    def initialize(year, model, color)
      @year = year
      @model = model
      @color = color
      @current_speed = 0
      @@number_of_vehicles += 1
    end

    def self.gas_mileage(gallons, miles)
      puts "#{miles / gallons} miles per gallon"
    end
    
    def speed_up(number)
      @current_speed += number
      puts "You hit the gas and accelerate #{number} mph."
    end

    def brake(number)
      @current_speed -= number
      puts "You hit the brakes and slow down #{number} MPH."
    end

    def current_speed
      puts "You're now going #{current_speed} MPH."
    end

    def shut_down
      @current_speed = 0
      puts "Let's park!"
    end

    def age
      puts "Your #{self.model} is #{calculate_vehicle_age} years old."
    end
    
    private

    def calculate_vehicle_age
      Time.now.year - self.year
    end
  end

  class MyCar < Vehicle
    NUMBER_OF_DOORS = 4

    def to_s
      "My car is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  class MyTruck < Vehicle
    include Haulable

    NUMBER_OF_DOORS = 2

    def to_s
      "My truck is a #{self.color}, #{self.year}, #{@model}."
    end
  end

  car = MyCar.new(2014, "Honda Civic", "brown")
  truck = MyTruck.new(2012, "Ford F150", "blue")

  puts car.age
  puts truck.age

#+END_SRC

*** Exercise 7
Create a class 'Student' with attributes *name* and *grade*. Do NOT make the grade getter public, so *joe.grade* will raise an error. Create a *better_grade_than?* method, that you can call like so...

#+BEGIN_SRC ruby
puts "Well done!" if joe.better_grade_than?(bob)
#+END_SRC

*** Solution 7
*File:* [[inheritance/exercise7.rb]]
#+BEGIN_SRC ruby :tangle inheritance/exercise7.rb
  # inheritance/exercise7.rb

  class Student

    attr_accessor :name, :grade 

    def initialize(name, grade)
      @name = name
      @grade = grade
    end

    def better_grade_than?(classmate)
      grade > classmate.grade
    end

    protected

    def grade
      @grade
    end
  end

  joe = Student.new("Joe", 94)
  bob = Student.new("Bob", 87)

  puts "True or false...Joe's grade is better than Bob's?"
  puts joe.better_grade_than?(bob)
  puts "==="
  puts "True or false...Bob's grade is better than Joe's?"
  puts bob.better_grade_than?(joe)
#+END_SRC

*** Exercise 8
Given the following code...

#+BEGIN_SRC ruby
bob = Person.new
bob.hi
#+END_SRC

And the corresponding error message...

#+BEGIN_SRC sh
NoMethodError: private method `hi' called for #<Person:0x007ff61dbb79f0>
from (irb):8
from /usr/local/rvm/rubies/ruby-2.0.0-rc2/bin/irb:16:in `<main>'
#+END_SRC

What is the problem and how would you go about fixing it?

*** Solution 8
*File:* [[inheritance/exercise8.md]]
#+BEGIN_SRC md
'hi' is a Private method. 

There are two ways to fix this. 

1. Make the private 'hi' method a public method.
2. Create a public method that references the private method.
#+END_SRC

* My notes from TutorialsPoint.com: Object Oriented Ruby
I went throug the object-oriented tutorial at this URL, and followed along with all the of the exercises:
http://www.tutorialspoint.com/ruby/ruby_object_oriented.htm

However, I've redacted the code from this file, into a local file called *lesson2-gitignore.org*, in order to comply with tutorialspoint.com's copyright. The tutorial is freely available, feel free to visit the link, to see what it includes!
* CodeAcademy Ruby Tutorials
I don't like using the built-in browser editor on CodeAcedemy, because it indent properly, and it lacks a lot of Emacs goodness. For more involved coding practice, I first typed in Emacs, and then pasted into the browser.
** Object-Oriented Programming I

#+BEGIN_SRC ruby
  class Language
    def initialize(name, creator)
      @name = name
      @creator = creator
    end

    def description
      puts "I'm #{@name} and I was created by #{@creator}!"
    end
  end

  ruby = Language.new("Ruby", "Yukihiro Matsumoto")
  python = Language.new("Python", "Guido van Rossum")
  javascript = Language.new("Javascript", "Brendan Eich")

  puts ruby.description
  puts python.description
  puts javascript.description                        
#+END_SRC

#+BEGIN_SRC ruby
  class Computer
    $manufacturer = "Mango Computer, Inc."
    @@files = {hello: "Hello, World!"}

    def initialize(username, password)
      @username = username
      @password = password
    end

    def current_user
      @username
    end

    def self.display_files
      @@files
    end
  end

  # Make a new Computer instance
  hal = Computer.new("Dave", 12345)

  puts "Current user: #{hal.current_user}"
  # @username belongs to the hal instance.

  puts "Manufacturer: #{$manufacturer}"
  # $manufacturer is global We can get it directly.

  puts "Files: #{Computer.display_files}"
  # @@files belongs to the Computer class.
#+END_SRC

Using a class veriable to keep track of the number of instances we've created:

#+BEGIN_SRC ruby
  class Person
    # Set your class variable to 0 on line 3
    @@people_count = 0

    def initialize(name)
      @name = name
      # Increment your class variable on line 8
      @@people_count += 1
    end

    def self.number_of_instances
      # Return your class variable on line 13
      @@people_count
    end
  end

  matz = Person.new("Yukihiro")
  dhh = Person.new("David")

  puts "Number of Person instances: #{Person.number_of_instances}"
#+END_SRC

#+BEGIN_SRC ruby
  class Computer
    @@users = {}

    def initialize(username, password)
      @username = username
      @password = password
      @@users[username] = password
      @files = {}
    end

    def create(filename)
      time = Time.now
    end

    def Computer.get_users
      return @@users
    end
  end

  my_computer = Computer.new("Andrew", "drowssaP!")
#+END_SRC

#+BEGIN_SRC ruby
  class Dog

    def initialize(name, breed)
      @name = name
      @breed = breed
    end

    public

    def bark
      puts "Woof!"
    end

    private

    def id
      @id_number = 12345
    end
  end
#+END_SRC

However, it's a pain to have to write our own /setter/ methods:

#+BEGIN_SRC ruby
  # ...

  # This step can be ommitted by using [attr_accessor, attr_writer, or attr_reader]
  def name
    @name
  end

  # ...
#+END_SRC

We can add *attr_writer* and *attr_reader* methods, and let Ruby set the variables for us:

#+BEGIN_SRC ruby
    class Person
      
      attr_reader :name
      attr_reader :job
      attr_writer :job

      def initialize(name, job)
        @name = name
        @job = job
      end
    end
#+END_SRC

Of course, I already knew that the *attr_accessor* method includes but the /getter/ *(attr_reader)* and /setter/ *(attr_writer)* methods, so the next refactoring was not a surprise... :)

#+BEGIN_SRC ruby
  class Person

    attr_reader :name
    attr_accessor :job

    def initialize(name, job)
      @name = name
      @job = job
    end
  end
#+END_SRC

"Whereas *include* mixes a module's methods in at the instance level (allowing instances of a particular class to use the methods), the extend keyword mixes a module's methods at the class level. This means that class itself can use the methods, as opposed to instances of the class."
[[http://www.codecademy.com/courses/ruby-beginner-en-zfe3o/2/3?curriculum_id%3D5059f8619189a5000201fbcb][Source]]

For example, in the following the class can access the mixed-in method, without instantiating an object, because we used *extend* rather than *include*:

#+BEGIN_SRC ruby
  # ThePresent has a .now method that we'll extend to TheHereAnd

  module ThePresent
    def now
      puts "It's #{Time.new.hour > 12 ? Time.new.hour - 12 : Time.new.hour}:#{Time.new.min} #{Time.new.hour > 12 ? 'PM' : 'AM'} (GMT)."
    end
  end

  class TheHereAnd
    extend ThePresent
  end

  TheHereAnd.now

#+END_SRC

*** Banking on Ruby
This is the model for the application I'll be building from scratch:

#+BEGIN_SRC ruby
class Account
  attr_reader :name, :balance
  def initialize(name, balance=100)
    @name = name
    @balance = balance
  end
  
  def display_balance(pin_number)
    puts pin_number == pin ? "Balance: $#{@balance}." : pin_error
  end
  
  def withdraw(pin_number, amount)
    if pin_number == pin
      @balance -= amount
      puts "Withdrew #{amount}. New balance: $#{@balance}."
    else
      puts pin_error
    end
  end
  
  private
  
  def pin
    @pin = 1234
  end
  
  def pin_error
    "Access denied: incorrect PIN."
  end
end

my_account = Account.new("Eric", 1_000_000)
my_account.withdraw(11, 500_000)
my_account.display_balance(1234)
my_account.withdraw(1234, 500_000)
my_account.display_balance(1234)

#+END_SRC

#+BEGIN_SRC ruby
  class Account

    attr_reader :name, :balance

    def initialize(name, balance=100)
      @name = name
      @balance = balance
    end

    def display_balance(pin_number)
      if @pin = pin?
        puts "Balance = $#{@balance}."
      else
        puts pin_error
      end
    end

    def withdraw(pin_number, amount)
      if @pin = pin?
        @balance -= amount
        puts "Withdrew #{amount}. New balance: $#{@balance}"
      else
        puts pin_error
      end
    end

    private

    def pin
      @pin = 1234
    end

    def pin_error
      return "Access denied: incorrect PIN."
    end
  end

  checking_account = Account.new("Andrew E. Buckingham", "29_000")
#+END_SRC

* Tealeaf Academy OOP Lecture, Part 1

** OOP in Ruby
*** Classes and Objects
- Classes are the blueprints for objects
- Classes are like the cookie cutter, and objects are the cookies
  - Objects will share the same basic form with other objects created from the same class, but they might have different states.
- methods contain behaviors
  - behaviors == instance methods ("Instance methods encapsulate behaviors that we want for our objects. It (sic) is /defined/ in a class." - Chris Lee, from 0:21:09)
- instance variables contain states
- objects are instantiated from classes, and contain states and behaviors.
- Class variables and methods
- compared with procedural programming


Example:
#+BEGIN_SRC ruby
  class Dog
    def speak
      puts "bark!"
    end
  end

  teddy = Dog.new
  teddy.speak

  fido = Dog.new
  fido.speak
#+END_SRC

At this point, there is no difference in state between *Dog* objects 'teddy' and 'fido'.

When we initialize these objects, we can pass their names as paramters. But that will cause an error, unless we initialize the parameter 'name':

#+BEGIN_SRC ruby
  class Dog
    def initialize(name)
      @name = name
    end

    def speak
      puts "bark!"
    end
  end

  teddy = Dog.new('Teddy')
  fido = Dog.new('Fido')

  teddy.speak
  fido.speak
#+END_SRC

*def intialize* provides the parameters that can be passed into objects, to define their states.

It's a good idea to always be consistant with your methods, in terms of whether you use 'puts' or return. In the example, we changed the *speak* method to /return/ the string, which meant that when we called the instance method (e.g., *teddy.speak*), we need to prepend *puts*. Here's how that looks:

#+BEGIN_SRC ruby
  class Dog

    def initialize(name, height, weight)
      @name = name
      @height = height
      @weight = weight
    end

    def speak
      @name + " barks!"
    end

    def get_name
      @name
    end

    def set_name=(new_name)
      @name = new_name
    end
    
    def info
      "#{@name} is #{@height} feet tall and weighs #{@weight} lbs."
  end

  # instantiate dog objects
  teddy = Dog.new("Teddy", 3, 95)
  fido = Dog.new("Fido", 1, 35)

  puts teddy.speak
  puts fido.speak
  puts teddy.get_name
  puts fido.get_name
  puts teddy.info
  puts fido.info

  teddy.set_name = "Roosevelt" # This will change teddy's name to 'Roosevelt'.
  puts teddy.info 
#+END_SRC

Here's a cool bit of Ruby syntatic sugar...When we create a 'setter', we can use either of the following:

*Version 1*
#+BEGIN_SRC ruby
  # ...

  def set_name=(new_name)
    @name = new_name
  end

  # ...

  teddy.set_name = "Roosevelt"

#+END_SRC

Or...

#+BEGIN_SRC ruby
  # ...

  def get_name(new_name)
    @name = new_name
  end

  # ...

  teddy.set_name("Roosevelt")
#+END_SRC

The result will be the same.

Also, we can abstract /getter/ methods and /setter/ methods:
- *attr_reader* corresponds to /getter/ methods. Ruby will automatically create 'get' methods for us.
- *attr_writer* corresponds to /setter/ methods. Ruby will automatically create 'set' methods for us.
- *attr_access* will create both /getter/ and /setter/ methods for us.

#+BEGIN_SRC ruby
  class Dog

    def initilialize(name, height, weight)
      @name = name
      @height = height
      @weight = weight
    end

    def speak
      @name + " barks!"
    end

    # We can remove the 'get_' from the getter method name
    def name
      @name
    end

    # We can remove the "set_' from the setter method name
    def name=(new_name)
      @name = new_name
    end

    def info
      "#{@name} is #{@height} feet tall and weighs #{@weight} lbs."
    end
  end

  teddy = Dog.new('Teddy', 3, 95)

  puts teddy.name # => 'Teddy' (puts the 'getter' method)
  teddy_name = "Roosevelt" # (this is the 'setter' method; the name is set to 'Roosevelt'.)
  puts teddy.info
#+END_SRC

We can use the *attr_* methods to automatically create /getter/ and /setter/ methods:

#+BEGIN_SRC ruby
  class Dog
    attr_accessor :name, :height, :weight

    def initialize(name, height, weight)
      @name = name
      @height = height
      @weight = weight
    end

    def speak
      @name + " barks!"
    end

    # note that we no longer need to define name!

    def info
      "#{@name} is #{@height} feed tall and weighs #{@weight} lbs."
    end
  end

  teddy = Dog.new('Teddy', 3, 95)

  puts teddy.name # => "Teddy"
  teddy.name = "Roosevelt"
  puts teddy.name # => "Roosevelt"
  puts teddy.height # => 3 feet tall
  puts teddy.weight # => 95 lbs.
#+END_SRC

In fact, because *attr_accessor* has created the getter/setter methods, rather than call the instance methods directly from within other instance methods, we can call the getter/setter methods that reference the instance methods, like this:

#+BEGIN_SRC ruby
  # ...

  def info
    "#{name} is #{height} feet tall and weighs #{weight} lbs."
  end

  # ...
#+END_SRC

And now, we can add a new *update_info* method:

#+BEGIN_SRC ruby
  class Dog
    attr_accessor :name, :height, :weight

    def initialize(name, height, weight)
      @name = name
      @height = height
      @weight = weight
    end

    def speak
      @name + " barks!"
    end

    def info
      "#{name} is #{height} feet tall and weighs #{weight} lbs."
    end

    # Adding another method. You must use 'self.' to let Ruby know you want to call the setter method, rather than set a local variable.
    def update_info(name, height, weight)
      self.name = name
      self.height = height
      self.weight = weight    
    end
  end

  teddy = Dog.new('Teddy' 3, 95)
  #fido = Dog.new('Fido', 1, 35)

  puts teddy.info
  teddy.update_update_info('Roosevelt', 5, 125)
  puts teddy.info
#+END_SRC


In the video, he gave a good example of what a getter and a setter method might look like. Note the syntax for each:

#+BEGIN_SRC ruby
  # getter method
  def ssn
    #555-55-5555
    "xxx-xx-" + @ssn.split('-').last
  end

  # setter method
  def ssn=(new_ssn)
    if valid_format?(new_ssn)
      @ssn = new_ssn
    end
  end
#+END_SRC

The 'getter' method 'gets' the data, so that it can have an action performed on it. The 'setter' method sets/updates the variable(s).

**** Class Variables
- start with two '@@' symbols: @@count = 0
- pertain to the class level, rather than at the object level
- Cannonical example is tracking how many objects are created
- instance methods should be wrapped in a 'def initilize' or 'def ...'; class variables can be anywhere (at the beginning) of the class definition

Here is an example of adding a class variable (@@count) to the program, to add the ability to count the number of instantiated objects:

#+BEGIN_SRC ruby
  class Dog
    @@count = 0

    attr_accessor :name, :height, :weight

    # Call Class Method
    def self.total_dogs
      "Total number of dogs: #{@@count}"
    end
      
    def initialize(name, height, weight)
      @name = name
      @height = height
      @weight = weight
      @@count += 1
    end

    def speak
      name + " barks!"
    end

    def info
      "#{name} is #{height} feet tall and weighs #{weight} lbs."
    end

    def update_info(name, height, weight)
      self.name = name
      self.height = height
      self.weight = weight
    end
  end

  teddy = Dog.new('Teddy', 3, 95)
  puts teddy.info

  # Call Class Method (note the use of 'self')
  puts  Dog.total_dogs
#+END_SRC

Chris reminded us that it's important not to see Rails code as "Rails magic," but rather just Ruby.
For example:

#+BEGIN_SRC ruby
# ...

User.all  # This is and example of calling a class method.
user = User.new # This is and example of intantiating a new object.
user.posts # This is and example of calling an instance method.

#+END_SRC

**** Procedural vs. OOP
One thing that Chris mentioned really made me chuckle. He brought down an example of the source code from the previous Procedural Ruby Blackjack game we built in the first lesson, and he talked about how just making one slight change could cause a ripple effect of bugs and issues down the line. That's something I really struggled with, and one of the reasons I was looking forward to moving on to object-oriented Ruby programming.

* Tealeaf Academy OOP Lecture, Part 2

- inheritance

#+BEGIN_SRC ruby
  class Dog
    attr_accessor :name

    def initialize(name)
      @name = name
    end

    def eat
      "#{name} is eating."
    end
  end


  class Cat
    attr_accessor :name
    
    def initialize(name)
      @name = name
    end

    def eat
      "#{name} is eating."
    end
  end

  teddy = Dog.new('Teddy')
  puts teddy.name

  kitty = Cat.new('Kitty')
  puts kitty.name

  puts teddy.eat
  puts kitty.eat
#+END_SRC

In the code above, we've created two class, *Dog* and *Cat*. Both of these classes share behaviors, such as eating, sleeping, or running. These behaviors can be extracted into a superclass, to reduce the redundancy.

#+BEGIN_SRC ruby
  class Animal
    attr_accessor :name

    def initialize(name)
      @name = name
    end

    def eat
      #{name} is eating."
    end

    def speak
      "#{name} is speaking!"
    end
    
  end

  class Mammal < Animal
    def warm_blooded?
      true
    end
  end

  module Swimmable
    def swim
      "I'm swimming!"
    end
  end

  # Note: In order to use this module, your class must respond to a 'name' method call.
  module Fetchable
    def fetch
      "#{name} is playing fetch!"
    end
  end

  class Dog < Mammal
    include Swimmable
    include Fetchable
    
    def speak
      "#{name} is barking!"
    end
  end

  class Cat < Mammal

    def speak
      "#{name} is meowing!"
    end
  end


  teddy = Dog.new('Teddy')
  puts teddy.name
  puts teddy.eat
  puts teddy.fetch
  puts teddy.speak
  puts teddy.swim

  kitty = Cat.new('Kitty')
  puts kitty.name
  puts kitty.eat
  puts kitty.speak
#+END_SRC

** Tips for Building games and apps in OOP
1. Have detailed requirements or specifications in written form (pseudo code).
2. Extract major nouns => classes
3. Extract major verbs => instance methods
4. Group instance methods into classes (this will take some practice)

For example...

For the OO Blackjack game, we'll use the following nouns:
- card
- deck
- player
- dealer

#+BEGIN_SRC ruby
  class Card
  attr_accessor :suit, :value

  def to_s
    "This is the card! #{suit}, #{card}"
  end
   
  def initialize (suit, value)
    @suit = suit
    @value = value
  end

  class Deck
    attr_accessor :cards

    def initialize(num_decks)
      @cards = []
      ['H', 'D', 'S', 'C']each.do |suit|
      ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'].each do |face_value|
        @cards << Card.new(suit, face_value)
      end
    end

    def scramble
      cards.shuffle!
    end

    def deal
      cards.pop
    end
  end

  class Player
  end

  class Dealer
  end


  class BlackJack
    attr_accessor :player, :dealer, :deck

    def initialize
      @player = player.new
      @dealer = dealer.new
      @deck = deck.new
    end

    def run
      deal_cards
      show_flow
      players.each do |player| # multiplayer functionality
        player_turn(player)
      end 
      dealer_turn
      who_won?
    end
  end
  Blackjack.new.run
#+END_SRC

* Object-Oriented Rock, Paper, Scissors (Janken)

** Requirements
The first step is to think about the specifications and requirements for the application, in plain English.

This version will be a two-player game. In Japan, when people play Janken, they can play with more than two people, but in the US, it's usuaally limited to two people.
- Player One
- Computer

There are three choices:
1. Rock
2. Paper
3. Scissors

There is a defined hierarchy of winner vs. loser:
1. Rock > Scissors
2. Paper > Rock
3. Scissors > Paper
4. Tie => Go again

I'll need to record each player's choice, and determin who won, using the hierarchy defined above.

** Implementation Ideas
1. Classes
   - Player
   - Hand

2. Game Play
   - Each Player gets to choose
   - The winner is announced
   - Play again?

3. Bonus Features I could implement
   - Keeping Score
   - Betting

For the initial commit, I'll copy in this pseudo code, and create the two classes, *Player* and *Hand*.
 
#+BEGIN_SRC ruby
  # Requirements:
  # The first step is to think about the specifications and requirements for the application, in plain English.

  # This version will be a two-player game. In Japan, when people play Janken, they can play with more than two people, but in the US, it's usuaally limited to two people.
  # - Player One
  # - Computer

  # There are three choices:
  # 1. Rock
  # 2. Paper
  # 3. Scissors

  # There is a defined hierarchy of winner vs. loser:
  # 1. Rock > Scissors
  # 2. Paper > Rock
  # 3. Scissors > Paper
  # 4. Tie => Go again

  # I'll need to record each player's choice, and determin who won, using the hierarchy defined above.

  # Implementation Ideas
  # 1. Classes
  # - Player
  # - Hand

  # 2. Game Play
  # - Each Player gets to choose
  # - The winner is announced
  # - Play again?

  # 3. Bonus Features I could implement (but probably won't for the sake of simplicity)
  # - Keeping Score
  # - Betting

  class Player
  end

  class Hand
    attr_accessor :paper, :rock, :scissors

    def initialize(paper, rock, scissors)
      @paper = paper
      @rock = rock
      @scissors = scissors
    end
  end
#+END_SRC

So one of the things that I was thinking about was that I should have a Superclass for Player, and then subclasses for the human and computer players. I was thinking that would be too complicated, but I think it might be a good idea, so that I can differentiate player methods from computer methods.

I'll create those classes, and add a *user_choice* method to the *HumanPlayer* class, and a *computer_choice* method to to the *ComputerPlayer* class:

#+BEGIN_SRC ruby
  class Person; end

  class HumanPlayer < Player
    def user_choice
      user_choice = gets.chomp.downcase
    end
  end

  class ComputerPlayer < Player
    def computer_choice
    end
  end

  class Hand
    attr_accessor :rock, :paper, :scissors

    def initialize(rock, paper, scissors)
      @rock = rock
      @paper = paper
      @scissors = scissors
    end
  end
#+END_SRC

I'll need to add a class for the game to play out. I also noticed that my first class should be *Player* and not *Person*. I'll change that now.

#+BEGIN_SRC ruby
  class Player
  end

  class HumanPlayer < Player
    def user_choice
      user_choice = gets.chomp.downcase
    end
  end

  class ComputerPlayer < Player
    def computer_choice
    end
  end

  class Hand
    attr_accessor :rock, :paper, :scissors

    def initialize(rock, paper, scissors)
      @rock = rock
      @paper = paper
      @scissors = scissors
    end
  end

  class Game
    # loop until there is a winner
    # user_choice
    # computer_choice
    # check_for_winner
    # declare winner
    # play again?
  end
#+END_SRC

In the [[https://github.com/XiaoA/tealeaf-course1-week1/blob/master/rock_paper_scissors_v2.rb][procedural version]] I wrote for Lesson 1, I created a hash with a 'CHOICES' constant, which defined the three hand choices. I think I can use that again.

#+BEGIN_SRC ruby
  class Player
  end

  class HumanPlayer < Player
    def user_choice
      user_choice = gets.chomp.downcase
    end
  end

  class ComputerPlayer < Player
    def computer_choice
    end
  end

  class Hand
    attr_accessor :rock, :paper, :scissors

    def initialize(rock, paper, scissors)
      @rock = rock
      @paper = paper
      @scissor = scissor
    end
  end

  class Game
    CHOICES = {'r' => 'Rock', 'p' => 'Paper', 's' => 'Scissors' }
    puts "Let's play 'Rock, Paper, Scissors!'"
    # loop until there is a winner
    # user_choice
    # computer_choice
    # check_for_winner
    # declare winner
    # play again?
  end
#+END_SRC

